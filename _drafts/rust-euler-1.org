---
title: hudat
layout: post
---

* First Try

Right now, I'm at that stage where I'm still not quite there with
Rust. I can do things, but I tend to get stuck, and I know


So, in order to keep interest and my momentum, I've been looking for
some small challenges. Project Euler seems perfect.

This first challenge is straightforward. Create a range, sum a
variable, and use the modulo operator. I came up with this solution
almost right away:

#+BEGIN_SRC
fn main() {
    let mut total = 0;
    for i in 1..1_000 {
        if is_addable(i) {
            total += i
        }
    }
    println!("{}", total);
}

fn is_addable(x: i64) -> bool {
    (x % 3) == 0 || (x % 5) == 0
}
#+END_SRC

The documentation for the ~1..1_000~ form is here:
http://doc.rust-lang.org/std/ops/struct.Range.html.
It was a little hard to find. I think this is because the most
prominent thing on the page shows the ~struct~ definition, but the
actual operators aren't really around.

* Adding a HOF

That was great, but I'm really interested in doing things
functionally. Can I ~filter~ the range, and then maybe ~sum~?

After a little bit of fiddling, this is what I came up with:

#+BEGIN_SRC
fn main() {
    let total = (1..1_000).filter(|i| is_addable(*i)).
        fold(0, |acc, i| acc + i);
    println!("{:?}", total);
}

fn is_addable(x: i64) -> bool {
    (x % 3) == 0 || (x % 5) == 0
}
#+END_SRC

Can I make this any better? I notice that the lambda around is_addable
seems unnecessary:

#+BEGIN_SRC
fn main() {
    let total = (1..1_000).filter(is_addable).
        fold(0, |acc, i| acc + i);
    println!("{:?}", total);
}

fn is_addable(x: &i64) -> bool {
    (x % 3) == 0 || (x % 5) == 0
}
#+END_SRC

Great, it still works.


* Peano numbers?

OK, this is a real stretch goal, but I'm feeling good about myself
because this all went pretty well.

I've always been a little bit intrigued by Peano numbers. You might
object that they're very slow -- they are -- but, I think they are
still interesting in terms of being conceptually very simple.

The other things is that I know Peano numbers will require some memory
management, which is something I want to exercise.


We start with the Peano enum:


enum Peano {
    Zero,
    Succ(Box<Peano>)
}


You might notice that this is almost the same as various Rust List
tutorials around. The ~Box~ call is for the same reason: Rust needs.


