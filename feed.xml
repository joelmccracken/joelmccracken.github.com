<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Joel&#39;s Journal</title>
    <description>Nebby about Tech</description>
    <link>http://joelmccracken.github.io</link>
    <atom:link href="http://joelmccracken.github.io/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>A Simple Web App in Rust, Conclusion: Putting Rust Aside for Now</title>
        <description>&lt;p&gt;
&lt;i&gt;Warning: this whole piece is full of opinion. It probably isn&#39;t surprising to anyone in the Rust community, but I want punctuate the series.&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
Several years ago, I worked on a series of blog posts entitled &quot;Building a Simple Webapp in Rust&quot;.
I hoped to return to it at some point, but I have not, and I doubt I ever will finish the series &amp;#x2013;
at this point, almost everything in the post is probably out of date.
&lt;/p&gt;

&lt;p&gt;
In one important sense, the project was a success: I learned a ton about Rust.
&lt;/p&gt;

&lt;p&gt;
I did eventually stop the project, and stop learning Rust.
Why? In short, I began to doubt that Rust held enough value &lt;b&gt;for me&lt;/b&gt; versus other avenues of interest.
It is clear to me that Rust is a great language for situations that require tight control over the hardware and performance.
Given a project with these requirements, I would absolutely start using Rust again.
If I had any situation where I would otherwise write C++, I would use Rust.
&lt;/p&gt;

&lt;p&gt;
However, hardware control is not the most important factor in most of the software I write.
I never write software in C++.
Clarity and maintainability are the most important factors, balanced against development time.
Performance issues can almost always be addressed after the software works, by performance testing and
making smart optimizations.
&lt;/p&gt;

&lt;p&gt;
There was one compelling reason for me to continue investigating Rust:
I have heard some say Rust is the most productive language for them,
and they believe this would apply to programmers in general.
The reasoning goes that the ownership system makes them think more about their code,
and in some ways significantly influences design for the better.
I think this is quite possible,
but I am not convinced enough to invest a significant amount of time in Rust.
I think my time is best spent elsewhere.
&lt;/p&gt;

&lt;p&gt;
Ultimately, I decided that my time would be better spent learning other things.
Specifically, Haskell (by way of Elm initially)
and other languages with powerful effects systems.
&lt;/p&gt;

&lt;p&gt;
&amp;#x2014;
&lt;/p&gt;

&lt;p&gt;
Series: A Simple Web App in Rust
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-1/&quot;&gt;Part 1&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-2a/&quot;&gt;Part 2a&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-2b/&quot;&gt;Part 2b&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-3/&quot;&gt;Part 3&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-4-cli-option-parsing/&quot;&gt;Part 4&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-conclusion/&quot;&gt;Conclusion&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 29 Dec 2017 22:48:58 -0500</pubDate>
        <link>http://joelmccracken.github.io//entries/a-simple-web-app-in-rust-conclusion/</link>
        <guid isPermaLink="true">http://joelmccracken.github.io//entries/a-simple-web-app-in-rust-conclusion/</guid>
      </item>
    
      <item>
        <title>Writing a &#39;Human Resource Machine&#39; Emulator in Elm</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. Goals and Ideas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-2&quot;&gt;2. MVP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-3&quot;&gt;3. The Program&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-3-1&quot;&gt;3.1. Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-3-2&quot;&gt;3.2. Program Scaffolding &amp;amp; View&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-3-3&quot;&gt;3.3. The Update&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
I&#39;m working on an Elm emulator for the the game
&lt;i&gt;&lt;a href=&quot;http://tomorrowcorporation.com/humanresourcemachine&quot;&gt;Human Resource Machine&lt;/a&gt;&lt;/i&gt;.
The goal of the game is to use a sort of &quot;assembly-like&quot; language to control a character
and have them perform requested tasks.
The player puts commands together by dragging commands around as blocks.
Its a basically a &quot;visual&quot; assembly language.
The levels in the game have been fun and challenging enough to keep me interested.
&lt;/p&gt;

&lt;p&gt;
Each level is presented as a conveyor belt inbox, a conveyor belt outbox, and some place to work with.
The player is asked to transform the input in some way, using the commands that are available for this level.
&lt;/p&gt;

&lt;p&gt;
I thought it would be a fun exercise to write an emulator for the the game in Elm.
I want to fix a number of usability issues I see in the game.
Also, I&#39;ve been wanting to learn to write games.
While this isn&#39;t a game, it is closely tied to a game,
and I think it addresses the same desire.
&lt;/p&gt;

&lt;p&gt;
I&#39;m still learning Elm, so this code probably has many flaws. Still, I
believe it is useful to see things through my eyes, as they are, now.
If you notice something that could be better, please, let me know
in the comments.
&lt;/p&gt;
&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; Goals and Ideas&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
What would make a good online emulator, something that people might find worth using?
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;The HRM editor is very basic. While good, I find it frustrating because of the inability
to write comments, among other things.
Later on in the game, you gain the ability to create little comment-y slips of paper, but
this requires you
to actually &quot;draw&quot; the words with your mouse/trackpad. It is really, really bad.
I&#39;d much rather work with &quot;normal&quot; comments, and there is no practical reason
&lt;/li&gt;
&lt;li&gt;Instead of working with text, in HRM you drag around boxes with words in them. This is more akin
to programming with the MIT scratch project than traditional programming. This
is OK, and I think it is a good idea for beginners, but I personally want to write text.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;2&lt;/span&gt; MVP&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;
&lt;p&gt;
I first wanted to write a &quot;proof-of-concept&quot;, from which I can add more features, over time.
&lt;/p&gt;

&lt;p&gt;
The smallest design that I could come up with for this proof-of-concept is:
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;Only emulate the first level, which has the most basic set of instructions.
&lt;/li&gt;
&lt;li&gt;Each second, apply the next instruction to the machine status.
&lt;/li&gt;
&lt;li&gt;Show the machine status after each instruction is calculated.
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The first level consists of a simple task: For each item on an inbox conveyor belt, place it on the outbox conveyor belt.
We are given two possible instructions: &#39;inbox&#39;, and &#39;outbox&#39;. The &#39;inbox&#39; command instructs the character to pick
something up off the inbox
and hold it in their hands. The &#39;outbox&#39; command says to place whatever is being held on the outbox.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;3&lt;/span&gt; The Program&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;
&lt;p&gt;
Lets go through the solution, piece by piece, starting with the most straightforward pieces first.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-3-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-3-1&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;3.1&lt;/span&gt; Model&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-3-1&quot;&gt;
&lt;p&gt;
The easiest way to represent instructions is as a Union type:
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-elm&quot;&gt;type Instruction = Inbox
		 | Outbox
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Hard-coding the solution program as an array of instructions makes this proof of concept easier:
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-elm&quot;&gt;program : Array Instruction
program =
  Array.fromList
	 [ Inbox
	 , Outbox
	 , Inbox
	 , Outbox
	 , Inbox
	 , Outbox
	 ]
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
It seems like every Elm program has a &quot;Model&quot; type, and this is no exception:
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-elm&quot;&gt;import Array exposing (Array)

type alias Model =
    { program : Array Instruction
    , status  : MachineStatus
    }
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
So, model is a combination between a program and an emulated &quot;machine&quot;.
&lt;/p&gt;

&lt;p&gt;
There is some forward thinking going on in this design. The model &lt;i&gt;could&lt;/i&gt; be
slightly simpler for this MVP, but part of the goal of this iteration is to
explore what the solution may look like in the future.
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;&lt;code&gt;program&lt;/code&gt; is listed as part of the model, although it needn&#39;t be in this case,
since it is hard-coded and won&#39;t change. However, we want this to be different
very soon, so it makes sense to just put this on the model, for now.
&lt;/li&gt;

&lt;li&gt;&lt;code&gt;status&lt;/code&gt; is a separate type because in the future I want to maintain a list of all statuss,
for debuggability. It becomes just a little easier to refactor to a list if it is
separate, and allows for a little bit of exploration of what a &lt;code&gt;MachineStatus&lt;/code&gt; type
should contain.
&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-elm&quot;&gt;type alias MachineStatus =
    { status : Status
    , held   : Maybe Value
    , input  : List Value
    , output : List Value
    , pc     : Int
    }

type Status = Running | Complete | Error String
&lt;/pre&gt;
&lt;/div&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;&lt;code&gt;status&lt;/code&gt; signifies execution completion. I strongly suspect that this will go somewhere else, as
it feels strange to have it in here. But, this is OK for now.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;held&lt;/code&gt; represents the current value that is being held. In HRM, what you
hold is akin to a CPU register; your character do calculations with and moves values to and
from their hands &amp;#x2013; which, really, is just like real life. This is a &lt;code&gt;Maybe&lt;/code&gt; because it is possible
for the hands to be empty.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;input&lt;/code&gt; represents the input conveyor. Values are taken from it and manipulated.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;output&lt;/code&gt; represents the output conveyor, onto which values are placed.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pc&lt;/code&gt; represents the &quot;program counter&quot;. This is the index of the next instruction to be executed.
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
You may notice that the above references a &lt;code&gt;Value&lt;/code&gt;. This is the &quot;values&quot; that may be worked with
in the game:
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-elm&quot;&gt;type Value = Int
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
For now, we are only working with integers.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-3-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-3-2&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;3.2&lt;/span&gt; Program Scaffolding &amp;amp; View&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-3-2&quot;&gt;
&lt;p&gt;
I&#39;m not sure where to mention this, but I want to include here the bits and pieces that
make the program actually run. I think its helpful to get them out of the way.
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-elm&quot;&gt;import Html.App as Html

main : Program Never
main =
  Html.program { init = init, view = view, update = update, subscriptions = subscriptions }
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
The program is an &lt;code&gt;Html.program&lt;/code&gt;, with the basic wiring.
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-elm&quot;&gt;import Time exposing (Time, second)

subscriptions : Model -&amp;gt; Sub Msg
subscriptions model =
  Time.every second Tick
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Tick each second. The only input the program receives for now are
ticks.
&lt;/p&gt;

&lt;p&gt;
The view can also be made fairly simple:
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-elm&quot;&gt;import Html exposing (Html, div, text)


-- VIEW

renderState : MachineState -&amp;gt; Html a
renderState state =
    div [] [text (toString state)]


view : Model -&amp;gt; Html Msg
view model =
  div []
    [ div [] [text (toString model.program)]
    , renderState model.state
    ]
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Instead of worrying about anything very complicated, we just use Elm&#39;s &lt;code&gt;toString&lt;/code&gt; method
to create a user-readable version of the data structure.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-3-3&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-3-3&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;3.3&lt;/span&gt; The Update&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-3-3&quot;&gt;
&lt;p&gt;
The &quot;meat&quot; of the application is the update functionality. This is the code that actually
emulates the machine.
&lt;/p&gt;

&lt;p&gt;
With our types defined, the code is not necessarily overly-complicated:
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-elm&quot;&gt;-- UPDATE

type Msg
  = Tick Time


update : Msg -&amp;gt; Model -&amp;gt; (Model, Cmd Msg)
update action model =
  case action of
    Tick newTime -&amp;gt;
	let
	    isComplete = model.state.status
	in
	    case isComplete of
		Running -&amp;gt; (stepModel model, Cmd.none)
		_       -&amp;gt; (model, Cmd.none)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
The function &lt;code&gt;update&lt;/code&gt; is the main loop. On each tick of the clock,
apply an instrution and compute the next version of the model
if the machine is still running.
&lt;/p&gt;

&lt;p&gt;
I didn&#39;t point this out earlier, but there are two other status types:
&lt;code&gt;Complete&lt;/code&gt; and &lt;code&gt;Error String&lt;/code&gt;. Complete indicates that the program completed
successfully, and is no longer running. &lt;code&gt;Error String&lt;/code&gt; provides a way to report
an error if the program tries to do something invalid, such as:
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;Finish without the correct values being on the output conveyor.
&lt;/li&gt;
&lt;li&gt;Tries to pick up something from the input conveyor when the conveyor is empty.
&lt;/li&gt;
&lt;li&gt;Tries to place something on the output conveyor when the character is not
holding anything.
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Although, there are others. Next up, &lt;code&gt;stepModel&lt;/code&gt;, which is where things begin
to get interesting.
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-elm&quot;&gt;stepModel : Model -&amp;gt; Model
stepModel model =
  let curr = currentInstruction model.program model.state.pc
  in case curr of
    Just instruction  -&amp;gt;
      processInstruction instruction model
    Nothing        -&amp;gt;
      updateState model (\s-&amp;gt; { s | status = Error &quot;The machine attempted to access an invalid instruction.&quot;})
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Before calculating the next state,
Calculating the next value of the model involves:
&lt;/p&gt;
&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;Finding the current instruction to execute.
&lt;/li&gt;
&lt;li&gt;Performing a specific action based upon the current instruction.
&lt;/li&gt;
&lt;li&gt;Performing some bookkeeping: Move to the next counter, complete
the state if the program has finished, etc.
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
Lets look at each of these functions, one at a time.
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-elm&quot;&gt;currentInstruction : Array Instruction -&amp;gt; Int -&amp;gt; Instruction
currentInstruction instructions pc =
  case (Array.get pc instructions) of
    Just a  -&amp;gt; a
    Nothing -&amp;gt; Debug.crash &quot;you&#39;re trying to access an instruction that doesn&#39;t exist&quot;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This is one of those situations where a type system makes things interesting. I wouldn&#39;t have
thought about &lt;code&gt;Array.get&lt;/code&gt; possibly failing without it returning a &lt;code&gt;Maybe&lt;/code&gt;, which I then have
to deal with.
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-elm&quot;&gt;updateState : Model -&amp;gt; (MachineState -&amp;gt; MachineState) -&amp;gt; Model
updateState model updater =
    let newState = updater model.state
    in { model | state = newState }


stepPC : Model -&amp;gt; Model
stepPC model =
    updateState model (\s-&amp;gt; {s | pc = s.pc + 1 })


completeIfFinished : Model -&amp;gt; Model
completeIfFinished model =
  let programLength = Array.length model.program
      pc = model.state.pc
  in if pc &amp;lt; programLength then
	 model
     else
	 updateState model complete


shiftInboxToHands : Model -&amp;gt; Model
shiftInboxToHands model =
  let first = List.head model.state.input
      rest  = case List.tail model.state.input of
		Just r  -&amp;gt; r
		Nothing -&amp;gt; []
  in case first of
       Just val -&amp;gt;
	   updateState model (\s-&amp;gt; { s | held = Just val, input = rest})
       Nothing -&amp;gt; updateState model (\s-&amp;gt; {s | status = Error &quot;tried to pick up an item from the inbox, but inbox was empty&quot; })


-- state manipulators

complete : MachineState -&amp;gt; MachineState
complete state = { state | status = Complete }


shiftHandsToOutbox : Model -&amp;gt; Model
shiftHandsToOutbox model =
  let currentState = model.state
  in case model.state.held of
    Nothing  -&amp;gt; updateState model complete
    Just val -&amp;gt; { model | state =
		     { currentState
			 | held = Nothing,
			   output  = (val :: currentState.output)
		     }}

stepModel : Model -&amp;gt; Model
stepModel model =
  let curr = currentInstruction model.program model.state.pc
  in case curr of
    Inbox -&amp;gt;
      shiftInboxToHands model |&amp;gt; stepPC |&amp;gt; completeIfFinished
    Outbox -&amp;gt;
      shiftHandsToOutbox model |&amp;gt; stepPC |&amp;gt; completeIfFinished
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 05 Jun 2016 22:01:24 -0400</pubDate>
        <link>http://joelmccracken.github.io//entries/writing-a-human-resource-machine-emulator-in-elm/</link>
        <guid isPermaLink="true">http://joelmccracken.github.io//entries/writing-a-human-resource-machine-emulator-in-elm/</guid>
      </item>
    
      <item>
        <title>Homebrew Command `brew leaves`: List Packages Without Dependents</title>
        <description>&lt;p&gt;
Have you ever wondered what packages you&#39;ve installed via
Homebrew? You know, the ones that you&#39;ve actually purposefully
installed:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
brew install &amp;lt;whatever&amp;gt;
&lt;/pre&gt;

&lt;p&gt;
I have always wanted this, for a number of reasons, but one
of the main reasons is to quickly see what software I have installed on
my machine.
&lt;/p&gt;

&lt;p&gt;
To be clear, &lt;code&gt;brew leaves&lt;/code&gt; doesn&#39;t actually show what you have manually
installed, but it shows the commands that have no dependents. &lt;code&gt;leaves&lt;/code&gt; is a
reasonable &lt;i&gt;approximation&lt;/i&gt; of this, though.
&lt;/p&gt;

&lt;p&gt;
Additionally, I like to use the command as a quick way to show things that I
can &lt;i&gt;probably&lt;/i&gt; remove from my system without worry. Something I use that isn&#39;t
in homebrew might still use the package, but you&#39;ll have that.
&lt;/p&gt;

&lt;p&gt;
&amp;#x2014;
&lt;/p&gt;

&lt;p&gt;
Sometimes, you just miss things in documentation.
I&#39;ve looked at the &lt;code&gt;brew&lt;/code&gt; man page a number of times while this feature
has been in homebrew, and I haven&#39;t ever noticed it. I&#39;m not sure if it was
a product of poor searching, or me reading it and not comprehending it.
The man page says this for the &lt;code&gt;leaves&lt;/code&gt; subcommand:
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
Show installed formulae that are not dependencies of another installed formula.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
You live and you learn.
&lt;/p&gt;
</description>
        <pubDate>Wed, 18 May 2016 22:02:12 -0400</pubDate>
        <link>http://joelmccracken.github.io//entries/brew-leaves/</link>
        <guid isPermaLink="true">http://joelmccracken.github.io//entries/brew-leaves/</guid>
      </item>
    
      <item>
        <title>How to Print a Struct in Rust</title>
        <description>&lt;p&gt;
So, you&#39;re programming in Rust, and one day you think it would be
really nice to be able to display a printed version of your structure in
memory.
&lt;/p&gt;

&lt;p&gt;
This is one of the handier things I&#39;ve learned to do while working
with Rust. I use it all the time, and while I&#39;ve memorized the
pattern, I don&#39;t want to forget again.
&lt;/p&gt;

&lt;p&gt;
So, here it is:
&lt;/p&gt;


&lt;pre class=&quot;example&quot;&gt;
#[derive(Debug)]
struct User {
    name: String,
    id: i32
}

fn main() {
    let user = User { name: &quot;Gary&quot;.to_string(), id: 1234 };
    println!(&quot;{:?}&quot;, user);
}
&lt;/pre&gt;

&lt;p&gt;
Compiling and running:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ rustc print-struct.rs
$ ./print-struct
User { name: &quot;Gary&quot;, id: 1234 }
&lt;/pre&gt;


&lt;p&gt;
Lets look at the pieces:
&lt;/p&gt;

&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;Add &lt;code&gt;#[derive(Debug)]&lt;/code&gt; above the struct definition to have rust
extend the debug trait.
&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;{:?}&lt;/code&gt; inside your &lt;code&gt;println!&lt;/code&gt; format string instead of the
usual &lt;code&gt;{}&lt;/code&gt;.
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
That&#39;s it! It is really simple, but it makes development sooo much easier.
&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Sep 2015 00:00:00 -0400</pubDate>
        <link>http://joelmccracken.github.io//entries/how-to-print-a-struct-in-rust/</link>
        <guid isPermaLink="true">http://joelmccracken.github.io//entries/how-to-print-a-struct-in-rust/</guid>
      </item>
    
      <item>
        <title>A Simple Web App in Rust, Part 4 -- CLI Option Parsing</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. Back from Hiatus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-2&quot;&gt;2. Intro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-3&quot;&gt;3. Requirements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-4&quot;&gt;4. Implementation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-5&quot;&gt;5. A Rant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-6&quot;&gt;6. Continuing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-7&quot;&gt;7. More Debugging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-8&quot;&gt;8. Regrouping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-9&quot;&gt;9. Refactoring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-10&quot;&gt;10. Conclusions &amp;amp; Retrospective on Part 4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; Back from Hiatus&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
Hello! Sorry for the delay in this one. My wife and I just bought a
house, and we have been dealing with all that. Thanks for your
patience.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;2&lt;/span&gt; Intro&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;
&lt;p&gt;
Last time, we built a &quot;working&quot; application; the proof-of-concept is
there. In order to make it into something that could actually be used,
we need to worry about some other things like adding command line
options.
&lt;/p&gt;

&lt;p&gt;
So, I&#39;m
going to do some command parsing. But first, lets move this existing
code out of the way to have a &quot;blank slate&quot; to do some CLI parsing
experimentation.
But, even before that, lets just generally clean things up a bit by
removing some old files, and then creating a new &lt;code&gt;main.rs&lt;/code&gt;:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ ls
Cargo.lock      Cargo.toml      log.txt         src             target
$ cd src/
$ ls
main.rs                 main_file_writing.rs    web_main.rs
&lt;/pre&gt;

&lt;p&gt;
&lt;code&gt;main_file_writing.rs&lt;/code&gt; and &lt;code&gt;web_main.rs&lt;/code&gt; are both old, so I can remove
them. After that I&#39;ll move &lt;code&gt;main.rs&lt;/code&gt; to, say, &lt;code&gt;main_logging_server.rs&lt;/code&gt;
and create a new &lt;code&gt;main.rs&lt;/code&gt;.
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ git rm main_file_writing.rs web_main.rs
rm &#39;src/main_file_writing.rs&#39;
rm &#39;src/web_main.rs&#39;
$ git commit -m &#39;remove old files&#39;
[master 771380b] remove old files
 2 files changed, 35 deletions(-)
 delete mode 100644 src/main_file_writing.rs
 delete mode 100644 src/web_main.rs
$ git mv main.rs main_logging_server.rs
$ git commit -m &#39;move main out of the way for cli parsing experiment&#39;
[master 4d24206] move main out of the way for cli parsing experiment
 1 file changed, 0 insertions(+), 0 deletions(-)
 rename src/{main.rs =&amp;gt; main_logging_server.rs} (100%)
$ touch main.rs
&lt;/pre&gt;


&lt;p&gt;
On to parameter parsing. In the comments section of an earlier post,
&lt;a href=&quot;http://blog.ssokolow.com/&quot;&gt;Stephan Sokolow&lt;/a&gt; asked if I had considered using the package &lt;a href=&quot;https://github.com/kbknapp/clap-rs&quot;&gt;clap&lt;/a&gt; for
command line parsing. Clap looks interesting, so, I&#39;ll try it.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;3&lt;/span&gt; Requirements&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;
&lt;p&gt;
The service needs to be parameterized for the following:
&lt;/p&gt;

&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;The location of the log file.
&lt;/li&gt;
&lt;li&gt;A secret token to authenticate with.
&lt;/li&gt;
&lt;li&gt;(Possibly) setting the time zone to use with logging.
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
I just checked the Digital Ocean VM that I&#39;m planning to use this on,
and the machine is in EST, which is also my time zone, so I&#39;ll
probably skip number 3, for now.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-4&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-4&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;4&lt;/span&gt; Implementation&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-4&quot;&gt;
&lt;p&gt;
As far as I can tell, the way to specify &lt;i&gt;this&lt;/i&gt; dependency is via
&lt;code&gt;clap = &quot;*&quot;;&lt;/code&gt;. I&#39;d always rather specify one, specific version, but
for now &quot;*&quot; will work.
&lt;/p&gt;

&lt;p&gt;
My new Cargo.toml:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
[package]
name = &quot;simple-log&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Joel McCracken &amp;lt;mccracken.joel@gmail.com&amp;gt;&quot;]

[dependencies]

chrono = &quot;0.2&quot;
clap   = &quot;*&quot;

[dependencies.nickel]

git = &quot;https://github.com/nickel-org/nickel.rs.git&quot;
&lt;/pre&gt;


&lt;p&gt;
Installing the dependency:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading ansi_term v0.6.3
 Downloading strsim v0.4.0
 Downloading clap v1.0.0-beta
   Compiling strsim v0.4.0
   Compiling ansi_term v0.6.3
   Compiling clap v1.0.0-beta
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
error: main function not found
error: aborting due to previous error
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
The error is just because my &lt;code&gt;main.rs&lt;/code&gt; file is still empty; the
important part is that the &quot;Compiling clap&quot; things look good.
&lt;/p&gt;

&lt;p&gt;
Based upon the README, I&#39;ll try the very simple version listed:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
extern crate clap;
use clap::App;

fn main() {
  let _ = App::new(&quot;fake&quot;).version(&quot;v1.0-beta&quot;).get_matches();
}
&lt;/pre&gt;
&lt;p&gt;
Running:
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
     Running `target/debug/simple-log`
$ cargo run
     Running `target/debug/simple-log`
$ cargo build --release
   Compiling lazy_static v0.1.10
   Compiling matches v0.1.2
   Compiling bitflags v0.1.1
   Compiling httparse v0.1.2
   Compiling strsim v0.4.0
   Compiling rustc-serialize v0.3.14
   Compiling modifier v0.1.0
   Compiling libc v0.1.8
   Compiling unicase v0.1.0
   Compiling groupable v0.2.0
   Compiling regex v0.1.30
   Compiling traitobject v0.0.3
   Compiling pkg-config v0.3.4
   Compiling ansi_term v0.6.3
   Compiling gcc v0.3.5
   Compiling typeable v0.1.1
   Compiling unsafe-any v0.4.1
   Compiling num_cpus v0.2.5
   Compiling rand v0.3.8
   Compiling log v0.3.1
   Compiling typemap v0.3.2
   Compiling clap v1.0.0-beta
   Compiling plugin v0.2.6
   Compiling mime v0.0.11
   Compiling time v0.1.25
   Compiling openssl-sys v0.6.2
   Compiling openssl v0.6.2
   Compiling url v0.2.34
   Compiling mustache v0.6.1
   Compiling num v0.1.25
   Compiling cookie v0.1.20
   Compiling hyper v0.4.0
   Compiling chrono v0.2.14
   Compiling nickel v0.5.0 (https://github.com/nickel-org/nickel.rs.git#69546f58)
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)

$ target/debug/simple-log --help
simple-log v1.0-beta

USAGE:
        simple-log [FLAGS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

$ target/release/simple-log --help
simple-log v1.0-beta

USAGE:
        simple-log [FLAGS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information
&lt;/pre&gt;

&lt;p&gt;
I don&#39;t know why the readme told me to compile with &lt;code&gt;--release&lt;/code&gt; &amp;#x2013; it
looks like the &lt;code&gt;debug&lt;/code&gt; worked the same way. Unless I don&#39;t understand
what&#39;s going on. Lemmie rm the target dir, then try again without the
release flag:
&lt;/p&gt;


&lt;pre class=&quot;example&quot;&gt;
$ rm -rf target
$ ls
Cargo.lock      Cargo.toml      log.txt         src
$ cargo build
   Compiling gcc v0.3.5
   Compiling strsim v0.4.0
   Compiling typeable v0.1.1
   Compiling unicase v0.1.0
   Compiling ansi_term v0.6.3
   Compiling modifier v0.1.0
   Compiling httparse v0.1.2
   Compiling regex v0.1.30
   Compiling matches v0.1.2
   Compiling pkg-config v0.3.4
   Compiling lazy_static v0.1.10
   Compiling traitobject v0.0.3
   Compiling rustc-serialize v0.3.14
   Compiling libc v0.1.8
   Compiling groupable v0.2.0
   Compiling bitflags v0.1.1
   Compiling unsafe-any v0.4.1
   Compiling clap v1.0.0-beta
   Compiling typemap v0.3.2
   Compiling rand v0.3.8
   Compiling num_cpus v0.2.5
   Compiling log v0.3.1
   Compiling time v0.1.25
   Compiling openssl-sys v0.6.2
   Compiling plugin v0.2.6
   Compiling mime v0.0.11
   Compiling openssl v0.6.2
   Compiling url v0.2.34
   Compiling num v0.1.25
   Compiling mustache v0.6.1
   Compiling cookie v0.1.20
   Compiling hyper v0.4.0
   Compiling chrono v0.2.14
   Compiling nickel v0.5.0 (https://github.com/nickel-org/nickel.rs.git#69546f58)
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
$ target/release/simple-log --help
bash: target/release/simple-log: No such file or directory
$ target/debug/simple-log --help
simple-log v1.0-beta

USAGE:
        simple-log [FLAGS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information
$
&lt;/pre&gt;

&lt;p&gt;
So, I guess you don&#39;t need that &lt;code&gt;--release&lt;/code&gt; flag. Ya learn something
new every day.
&lt;/p&gt;

&lt;p&gt;
Also, looking at the &lt;code&gt;main&lt;/code&gt; code again, I notice that the variable is
named &lt;code&gt;_&lt;/code&gt;; I assume this must be in order to silence warnings/signify
disuse. Using &lt;code&gt;_&lt;/code&gt; to signify &quot;intentionally unused&quot; is pretty
standard, I like that Rust supports this.
&lt;/p&gt;

&lt;p&gt;
So, based upon the clap readme and a little experimentation, I&#39;ve come
up with this first attempt at writing an argument parser:
&lt;/p&gt;


&lt;pre class=&quot;example&quot;&gt;
extern crate clap;
use clap::{App,Arg};

fn main() {
    let matches = App::new(&quot;simple-log&quot;).version(&quot;v0.0.1&quot;)
        .arg(Arg::with_name(&quot;LOG FILE&quot;)
             .short(&quot;l&quot;)
             .long(&quot;logfile&quot;)
             .takes_value(true))
        .get_matches();

    println!(&quot;Logfile path: {}&quot;, matches.value_of(&quot;LOG FILE&quot;).unwrap());

}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run -- --logfile whodat
     Running `target/debug/simple-log --logfile whodat`
Logfile path: whodat
$ cargo run -- -l whodat
     Running `target/debug/simple-log -l whodat`
Logfile path: whodat
&lt;/pre&gt;

&lt;p&gt;
Ok, so that worked! But here&#39;s a problem:
&lt;/p&gt;


&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-$&quot;&gt;$ cargo run
     Running `target/debug/simple-log`
thread &#39;&amp;lt;main&amp;gt;&#39; panicked at &#39;called `Option::unwrap()` on a `None` value&#39;, /private/tmp/rust2015051
6-38954-h579wb/rustc-1.0.0/src/libcore/option.rs:362
An unknown error occurred

To learn more, run the command again with --verbose.
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
So. Calling &lt;code&gt;unwrap()&lt;/code&gt; up there was a bad idea, since this argument
may not be passed in!
&lt;/p&gt;

&lt;p&gt;
I&#39;m not sure what the opinion of the greater Rust community is on
&lt;code&gt;unwrap&lt;/code&gt;, but everywhere I&#39;ve noticed it there is also a comment
explaining why it should be OK to use here. While I think that makes
sense, as an application grows it is easy for assumptions in one place
to become invalidated. And, notice that the error occurs at
&lt;i&gt;run-time&lt;/i&gt;. This isn&#39;t something that the compiler can determine!
&lt;/p&gt;

&lt;p&gt;
Is &lt;code&gt;unwrap&lt;/code&gt; the same basic idea as there being a null pointer
exception? I think so. But, it does make you stop and
think about what you&#39;re doing, and if it means that &lt;code&gt;unwrap&lt;/code&gt; is a code
sort-of-smell, then that&#39;s great. Which leads me to a bit of a rant:
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-5&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-5&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;5&lt;/span&gt; A Rant&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-5&quot;&gt;
&lt;p&gt;
I firmly believe that you cannot make developers write good
code. The problem I have with static language communities is that the
rhetoric around these programming languages: that they will &quot;prevent the programmer
from doing bad things&quot;. Well, guess what: that&#39;s impossible.
&lt;/p&gt;

&lt;p&gt;
Firstly, you cannot define &quot;good code&quot; in any sensible way. Indeed, much of
what makes code good is highly context-dependent. As a very basic
example, sloppy code is good when prototyping, but sloppy code is
horrible when making something production-quality.
&lt;/p&gt;

&lt;p&gt;
The latest OpenSSL vulnerability is a great example of this.
I didn&#39;t read very much into the news about the vulnerability,
but from what I gathered, the cause of the bug was
&lt;i&gt;an error in business logic&lt;/i&gt;. Under certain very-specific
circumstances, an attacker could become a certificate authority. How
do you write a compiler that prevents &lt;i&gt;this&lt;/i&gt; problem?
&lt;/p&gt;

&lt;p&gt;
Indeed, this takes me back to an old quote from Charles Babbage:
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
On two occasions I have been asked,   &quot;Pray, Mr. Babbage, if you put
into the machine wrong figures, will the right answers come out?&quot; In
one case a member of the Upper, and in the other a member of the
Lower, House put this question. I am not able rightly to apprehend the
kind of confusion of ideas that could provoke such a question.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
The best thing that you can do is make it &lt;i&gt;easier&lt;/i&gt; for developers to write
good code. Doing the right thing should be the normal, easy path.
&lt;/p&gt;

&lt;p&gt;
Once you start talking about static type systems as tools to make
programming &lt;i&gt;easier&lt;/i&gt;, I think things start to make sense again. In the end,
the developer is still responsible for doing the right thing, and we
must &lt;i&gt;trust&lt;/i&gt; them and &lt;i&gt;empower&lt;/i&gt; them to do these things.
&lt;/p&gt;

&lt;p&gt;
Finally: the programmer can always implement a little
Scheme interpreter and write all their application logic in that. Good
luck trying to get your type checker to prevent that sort of thing.
&lt;/p&gt;

&lt;p&gt;
Ok, I&#39;m done. I&#39;ll get down off my soapbox. Thanks for indulging me.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-6&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-6&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;6&lt;/span&gt; Continuing&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-6&quot;&gt;
&lt;p&gt;
Back in the real world, I notice that there is an option for an &lt;code&gt;Arg&lt;/code&gt;
that specifies that the argument is required. I think I&#39;d like to use
that here:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
extern crate clap;
use clap::{App,Arg};

fn main() {
    let matches = App::new(&quot;simple-log&quot;).version(&quot;v0.0.1&quot;)
        .arg(Arg::with_name(&quot;LOG FILE&quot;)
             .short(&quot;l&quot;)
             .long(&quot;logfile&quot;)
             .required(true)
             .takes_value(true))
        .get_matches();

    println!(&quot;Logfile path: {}&quot;, matches.value_of(&quot;LOG FILE&quot;).unwrap());

}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
     Running `target/debug/simple-log`
error: The following required arguments were not supplied:
        &#39;--logfile &amp;lt;LOG FILE&amp;gt;&#39;

USAGE:
        simple-log --logfile &amp;lt;LOG FILE&amp;gt;

For more information try --help
An unknown error occurred

To learn more, run the command again with --verbose.
$ cargo run -- -l whodat
     Running `target/debug/simple-log -l whodat`
Logfile path: whodat
&lt;/pre&gt;

&lt;p&gt;
It works! The next we need option is to specify a secret token via the
command line.
Lets add that, but make it optional because, well, why
not? I might want to put up an open version of this for people to see.
&lt;/p&gt;

&lt;p&gt;
I&#39;m left with this:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
extern crate clap;
use clap::{App,Arg};

fn main() {
    let matches = App::new(&quot;simple-log&quot;).version(&quot;v0.0.1&quot;)
        .arg(Arg::with_name(&quot;LOG FILE&quot;)
             .short(&quot;l&quot;)
             .long(&quot;logfile&quot;)
             .required(true)
             .takes_value(true))
        .arg(Arg::with_name(&quot;AUTH TOKEN&quot;)
             .short(&quot;t&quot;)
             .long(&quot;token&quot;)
             .takes_value(true))
        .get_matches();

    let logfile_path = matches.value_of(&quot;LOG FILE&quot;).unwrap();
    let auth_token   = matches.value_of(&quot;AUTH TOKEN&quot;);
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run -- -l whodat
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:17:9: 17:21 warning: unused variable: `logfile_path`, #[warn(unused_variables)] on by d
efault
src/main.rs:17     let logfile_path = matches.value_of(&quot;LOG FILE&quot;).unwrap();
                       ^~~~~~~~~~~~
src/main.rs:18:9: 18:19 warning: unused variable: `auth_token`, #[warn(unused_variables)] on by default
src/main.rs:18     let auth_token   = matches.value_of(&quot;AUTH TOKEN&quot;);
                       ^~~~~~~~~~
     Running `target/debug/simple-log -l whodat`
&lt;/pre&gt;


&lt;p&gt;
There are a lot of (expected) warnings, but it compiles and
runs fine. I just wanted it to type-check. Now lets bring this back to
the real program. I start with the code below:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
use std::io::prelude::*;
use std::fs::OpenOptions;
use std::io;

#[macro_use] extern crate nickel;
use nickel::Nickel;

extern crate chrono;
use chrono::{DateTime,Local};

extern crate clap;
use clap::{App,Arg};

fn formatted_time_entry() -&amp;gt; String {
    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    let formatted = local.format(&quot;%a, %b %d %Y %I:%M:%S %p\n&quot;).to_string();
    formatted
}

fn record_entry_in_log(filename: &amp;amp;str, bytes: &amp;amp;[u8]) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let mut file = try!(OpenOptions::new().
                        append(true).
                        write(true).
                        create(true).
                        open(filename));
    try!(file.write_all(bytes));
    Ok(())
}

fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;String&amp;gt; {
    let entry = formatted_time_entry();
    {
        let bytes = entry.as_bytes();

        try!(record_entry_in_log(filename, &amp;amp;bytes));
    }
    Ok(entry)
}

fn do_log_time(logfile_path: &amp;amp;&#39;static str, auth_token: Option&amp;lt;&amp;amp;str&amp;gt;) -&amp;gt; String {
    match log_time(logfile_path) {
        Ok(entry) =&amp;gt; format!(&quot;Entry Logged: {}&quot;, entry),
        Err(e) =&amp;gt; format!(&quot;Error: {}&quot;, e)
    }
}

fn main() {
    let matches = App::new(&quot;simple-log&quot;).version(&quot;v0.0.1&quot;)
        .arg(Arg::with_name(&quot;LOG FILE&quot;)
             .short(&quot;l&quot;)
             .long(&quot;logfile&quot;)
             .required(true)
             .takes_value(true))
        .arg(Arg::with_name(&quot;AUTH TOKEN&quot;)
             .short(&quot;t&quot;)
             .long(&quot;token&quot;)
             .takes_value(true))
        .get_matches();

    let logfile_path = matches.value_of(&quot;LOG FILE&quot;).unwrap();
    let auth_token   = matches.value_of(&quot;AUTH TOKEN&quot;);

    let mut server = Nickel::new();

    server.utilize(router! {
        get &quot;**&quot; =&amp;gt; |_req, _res| {
            do_log_time(logfile_path, auth_token)
        }
    });

    server.listen(&quot;127.0.0.1:6767&quot;);
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run -- -l whodat
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:60:24: 60:31 error: `matches` does not live long enough
src/main.rs:60     let logfile_path = matches.value_of(&quot;LOG FILE&quot;).unwrap();
                                      ^~~~~~~
note: reference must be valid for the static lifetime...
src/main.rs:58:24: 72:2 note: ...but borrowed value is only valid for the block suffix following st
atement 0 at 58:23
src/main.rs:58         .get_matches();
src/main.rs:59
src/main.rs:60     let logfile_path = matches.value_of(&quot;LOG FILE&quot;).unwrap();
src/main.rs:61     let auth_token   = matches.value_of(&quot;AUTH TOKEN&quot;);
src/main.rs:62
src/main.rs:63     let mut server = Nickel::new();
               ...
src/main.rs:61:24: 61:31 error: `matches` does not live long enough
src/main.rs:61     let auth_token   = matches.value_of(&quot;AUTH TOKEN&quot;);
                                      ^~~~~~~
note: reference must be valid for the static lifetime...
src/main.rs:58:24: 72:2 note: ...but borrowed value is only valid for the block suffix following st
atement 0 at 58:23
src/main.rs:58         .get_matches();
src/main.rs:59
src/main.rs:60     let logfile_path = matches.value_of(&quot;LOG FILE&quot;).unwrap();
src/main.rs:61     let auth_token   = matches.value_of(&quot;AUTH TOKEN&quot;);
src/main.rs:62
src/main.rs:63     let mut server = Nickel::new();
               ...
error: aborting due to 2 previous errors
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;


&lt;p&gt;
I don&#39;t understand what is wrong &amp;#x2013; this is essentially the same code
as from the example.
I tried commenting out a bunch of code besides what is essentially this:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
fn main() {
    let matches = App::new(&quot;simple-log&quot;).version(&quot;v0.0.1&quot;)
        .arg(Arg::with_name(&quot;LOG FILE&quot;)
             .short(&quot;l&quot;)
             .long(&quot;logfile&quot;)
             .required(true)
             .takes_value(true))
        .arg(Arg::with_name(&quot;AUTH TOKEN&quot;)
             .short(&quot;t&quot;)
             .long(&quot;token&quot;)
             .takes_value(true))
        .get_matches();

    let logfile_path = matches.value_of(&quot;LOG FILE&quot;).unwrap();
    let auth_token   = matches.value_of(&quot;AUTH TOKEN&quot;);
}
&lt;/pre&gt;

&lt;p&gt;
&amp;#x2026; and now it compiles. There are lots of warnings, but that&#39;s fine.
&lt;/p&gt;

&lt;p&gt;
None of the error messages above refer to any lines that are commented
out. Now that I know that the error message do not refer to what is
causing the problem, I know to look elsewhere.
&lt;/p&gt;

&lt;p&gt;
The first thing I do is remove the references to those two
variables. The code becomes this:
&lt;/p&gt;


&lt;pre class=&quot;example&quot;&gt;
fn main() {
    let matches = App::new(&quot;simple-log&quot;).version(&quot;v0.0.1&quot;)
        .arg(Arg::with_name(&quot;LOG FILE&quot;)
             .short(&quot;l&quot;)
             .long(&quot;logfile&quot;)
             .required(true)
             .takes_value(true))
        .arg(Arg::with_name(&quot;AUTH TOKEN&quot;)
             .short(&quot;t&quot;)
             .long(&quot;token&quot;)
             .takes_value(true))
        .get_matches();

    let logfile_path = matches.value_of(&quot;LOG FILE&quot;).unwrap();
    let auth_token   = matches.value_of(&quot;AUTH TOKEN&quot;);


    let mut server = Nickel::new();
    server.utilize(router! {
        get &quot;**&quot; =&amp;gt; |_req, _res| {
            do_log_time(&quot;&quot;, Some(&quot;&quot;))
        }
    });

    server.listen(&quot;127.0.0.1:6767&quot;);
}
&lt;/pre&gt;

&lt;p&gt;
This compiles and runs correctly. Now that I know this is the problem,
I &lt;i&gt;suspect&lt;/i&gt; that this is because the get request is routing to the
&lt;code&gt;get **&lt;/code&gt; closure, and importing these variables into a closure would
clearly impact their lifetimes.
&lt;/p&gt;

&lt;p&gt;
I talked with my friend &lt;a href=&quot;https://twitter.com/Carols10cents&quot;&gt;Carol Nichols&lt;/a&gt; about the problem, and she was
able to suggest something that got me one step closer: convert
&lt;code&gt;logfile_path&lt;/code&gt; and &lt;code&gt;auth_token&lt;/code&gt; to &lt;code&gt;String&lt;/code&gt; types.
&lt;/p&gt;

&lt;p&gt;
What I believe is going on here is that &lt;code&gt;logfile_path&lt;/code&gt; and
&lt;code&gt;auth_token&lt;/code&gt; are both borrowed &lt;code&gt;str&lt;/code&gt; types from somewhere inside the
&lt;code&gt;matches&lt;/code&gt; data structure, which goes out of scope&amp;#x2026; some time. At the
end of &lt;code&gt;main&lt;/code&gt;? Since &lt;code&gt;main&lt;/code&gt; should still be running
while the closure exists, it seems like &lt;code&gt;matches&lt;/code&gt; should still exist.
&lt;/p&gt;

&lt;p&gt;
Alternatively, it might be that closures just don&#39;t work with
borrows. This seems &lt;i&gt;unlikely&lt;/i&gt; to me. It seems more likely that the
compiler can&#39;t &lt;i&gt;prove&lt;/i&gt; that &lt;code&gt;matches&lt;/code&gt; will still exist while closure
could still be invoked. Although this &lt;i&gt;still&lt;/i&gt; doesn&#39;t make sense,
since the closure is passed into &lt;code&gt;server&lt;/code&gt;, which would go out of scope
at the same time as &lt;code&gt;matches&lt;/code&gt;!
&lt;/p&gt;

&lt;p&gt;
But anyway, changing this code:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
// ...
let logfile_path = matches.value_of(&quot;LOG FILE&quot;).unwrap();
let auth_token   = matches.value_of(&quot;AUTH TOKEN&quot;);

let mut server = Nickel::new();
server.utilize(router! {
    get &quot;**&quot; =&amp;gt; |_req, _res| {
        do_log_time(logfile_path, auth_token)
    }
});
// ...
&lt;/pre&gt;

&lt;p&gt;
into this:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
// ...
let logfile_path = matches.value_of(&quot;LOG FILE&quot;).unwrap().to_string();
let auth_token = match matches.value_of(&quot;AUTH TOKEN&quot;) {
    Some(str) =&amp;gt; Some(str.to_string()),
    None =&amp;gt; None
};

let mut server = Nickel::new();
server.utilize(router! {
    get &quot;**&quot; =&amp;gt; |_req, _res| {
        do_log_time(logfile_path, auth_token)
    }
});

server.listen(&quot;127.0.0.1:6767&quot;);
// ...
&lt;/pre&gt;

&lt;p&gt;
&amp;#x2026; fixed the problem. I also had to change the various functions that
take &lt;code&gt;&amp;amp;str&lt;/code&gt; types to take &lt;code&gt;String&lt;/code&gt; types.
&lt;/p&gt;

&lt;p&gt;
Of course, this reveals a &lt;i&gt;new&lt;/i&gt; problem:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo build
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:69:25: 69:37 error: cannot move out of captured outer variable in an `Fn` closure
src/main.rs:69             do_log_time(logfile_path, auth_token)
                                       ^~~~~~~~~~~~
&amp;lt;nickel macros&amp;gt;:1:1: 1:27 note: in expansion of as_block!
&amp;lt;nickel macros&amp;gt;:10:12: 10:42 note: expansion site
note: in expansion of closure expansion
&amp;lt;nickel macros&amp;gt;:9:6: 10:54 note: expansion site
&amp;lt;nickel macros&amp;gt;:1:1: 10:62 note: in expansion of _middleware_inner!
&amp;lt;nickel macros&amp;gt;:4:1: 4:60 note: expansion site
&amp;lt;nickel macros&amp;gt;:1:1: 7:46 note: in expansion of middleware!
&amp;lt;nickel macros&amp;gt;:11:32: 11:78 note: expansion site
&amp;lt;nickel macros&amp;gt;:1:1: 21:78 note: in expansion of _router_inner!
&amp;lt;nickel macros&amp;gt;:4:1: 4:43 note: expansion site
&amp;lt;nickel macros&amp;gt;:1:1: 4:47 note: in expansion of router!
src/main.rs:67:20: 71:6 note: expansion site
src/main.rs:69:39: 69:49 error: cannot move out of captured outer variable in an `Fn` closure
src/main.rs:69             do_log_time(logfile_path, auth_token)
                                                     ^~~~~~~~~~
&amp;lt;nickel macros&amp;gt;:1:1: 1:27 note: in expansion of as_block!
&amp;lt;nickel macros&amp;gt;:10:12: 10:42 note: expansion site
note: in expansion of closure expansion
&amp;lt;nickel macros&amp;gt;:9:6: 10:54 note: expansion site
&amp;lt;nickel macros&amp;gt;:1:1: 10:62 note: in expansion of _middleware_inner!
&amp;lt;nickel macros&amp;gt;:4:1: 4:60 note: expansion site
&amp;lt;nickel macros&amp;gt;:1:1: 7:46 note: in expansion of middleware!
&amp;lt;nickel macros&amp;gt;:11:32: 11:78 note: expansion site
&amp;lt;nickel macros&amp;gt;:1:1: 21:78 note: in expansion of _router_inner!
&amp;lt;nickel macros&amp;gt;:4:1: 4:43 note: expansion site
&amp;lt;nickel macros&amp;gt;:1:1: 4:47 note: in expansion of router!
src/main.rs:67:20: 71:6 note: expansion site
error: aborting due to 2 previous errors
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
At first glance, this error doesn&#39;t make any sense to me:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
src/main.rs:69:25: 69:37 error: cannot move out of captured outer variable in an `Fn` closure
src/main.rs:69             do_log_time(logfile_path, auth_token)
&lt;/pre&gt;

&lt;p&gt;
What does it mean to &quot;move out of&quot; a captured variable? I don&#39;t
remember anything that used language like moving in to or out of
variables, and besides, that sentence doesn&#39;t make any sense to me.
&lt;/p&gt;

&lt;p&gt;
The error also says some other weird stuff; what does a
&lt;code&gt;Fn&lt;/code&gt; closure have to do with any of this?
&lt;/p&gt;

&lt;p&gt;
I searched the Internet a while for this error message, and found some
results. However, none of them seemed like they applied to me. So,
back to playing around
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-7&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-7&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;7&lt;/span&gt; More Debugging&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-7&quot;&gt;
&lt;p&gt;
First, I tried compiling with the &lt;code&gt;--verbose&lt;/code&gt; flag just to see if was
helpful, but it did not print any additional debugging information
about the error, only about the general command.
&lt;/p&gt;

&lt;p&gt;
I remembered seeing a section specific to closures in the the Rust
book, so I decided to look at that. From it, my guess is that I need
to do a &quot;move&quot; closure. But, when I try it:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
server.utilize(router! {
    get &quot;**&quot; =&amp;gt; move |_req, _res| {
        do_log_time(logfile_path, auth_token)
    }
});
&lt;/pre&gt;

&lt;p&gt;
&amp;#x2026; I get a new error message:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run -- -l whodat
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:66:21: 66:25 error: no rules expected the token `move`
src/main.rs:66         get &quot;**&quot; =&amp;gt; move |_req, _res| {
                                   ^~~~
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
This confused me, so I decided to just try to move it outside:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
foo = move |_req, _res| {
    do_log_time(logfile_path, auth_token)
};

server.utilize(router! {
    get &quot;**&quot; =&amp;gt; foo
});
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run -- -l whodat
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:70:21: 70:24 error: no rules expected the token `foo`
src/main.rs:70         get &quot;**&quot; =&amp;gt; foo
                                   ^~~
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
This is the same error message.
&lt;/p&gt;

&lt;p&gt;
At this point, I notice that the language of the error message sounds
suspiciously like the wording used around Scheme pattern matching
macro systems, and I remember the &lt;code&gt;router!&lt;/code&gt; macro being used
here. Some macro weirdness! I know how to solve this, because I had to
deal with it before.
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ rustc src/main.rs --pretty=expanded -Z unstable-options
src/main.rs:5:14: 5:34 error: can&#39;t find crate for `nickel`
src/main.rs:5 #[macro_use] extern crate nickel;
&lt;/pre&gt;

&lt;p&gt;
So, I guess I need to pass this argument to cargo? Searching
cargo docs doesnt seem to show anything about passing &lt;code&gt;rustc&lt;/code&gt; arguments.
&lt;/p&gt;

&lt;p&gt;
Searching the Internet, I found some GitHub issues that indicate
sending arbitrary arguments
is not supported, besides creating a custom cargo command.
Creating a custom cargo command sounds like an awful diversion from
the problem I am trying to solve right now, so I don&#39;t want to go down
that route.
&lt;/p&gt;

&lt;p&gt;
Suddenly, a wild idea appears: when using &lt;code&gt;cargo run --verbose&lt;/code&gt;, I saw this
&lt;code&gt;rustc&lt;/code&gt; command in its output:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
# ...
Caused by:
  Process didn&#39;t exit successfully: `rustc src/main.rs --crate-name simple_log --crate-type bin -g -
-out-dir /Users/joel/Projects/simple-log/target/debug --emit=dep-info,link -L dependency=/Users/joel
/Projects/simple-log/target/debug -L dependency=/Users/joel/Projects/simple-log/target/debug/deps --
extern nickel=/Users/joel/Projects/simple-log/target/debug/deps/libnickel-0a4cb77ee6c08a8b.rlib --ex
tern chrono=/Users/joel/Projects/simple-log/target/debug/deps/libchrono-a9b06d7e3a59ae0d.rlib --exte
rn clap=/Users/joel/Projects/simple-log/target/debug/deps/libclap-01156bdabdb6927f.rlib -L native=/U
sers/joel/Projects/simple-log/target/debug/build/openssl-sys-9c1a0f13b3d0a12d/out -L native=/Users/j
oel/Projects/simple-log/target/debug/build/time-30c208bd835b525d/out` (exit code: 101)
# ...
&lt;/pre&gt;

&lt;p&gt;
&amp;#x2026; which makes me wonder: Could I modify this to make it compile and
output the macro-expanded code? Trying it:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ rustc src/main.rs --crate-name simple_log --crate-type bin -g --out-dir /Users/joel/Projects/simple-log/target/debug --emit=dep-info,link -L dependency=/Users/joel/Projects/simple-log/target/debug -L
dependency=/Users/joel/Projects/simple-log/target/debug/deps --extern nickel=/Users/joel/Projects/simple-log/target/debug/deps/libnickel-0a4cb77ee6c08a8b.rlib --extern chrono=/Users/joel/Projects/simple
-log/target/debug/deps/libchrono-a9b06d7e3a59ae0d.rlib --extern clap=/Users/joel/Projects/simple-log/target/debug/deps/libclap-01156bdabdb6927f.rlib -L native=/Users/joel/Projects/simple-log/target/debu
g/build/openssl-sys-9c1a0f13b3d0a12d/out -L native=/Users/joel/Projects/simple-log/target/debug/build/time-30c208bd835b525d/out --pretty=expanded -Z unstable-options &amp;gt; macro-expanded.rs
$ cat macro-expanded.rs
#![feature(no_std)]
#![no_std]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std as std;
use std::io::prelude::*;
...
&lt;/pre&gt;

&lt;p&gt;
It worked! It is inelegant, but at least I was able to
figure it out. It is also clearer to me how the &lt;code&gt;cargo&lt;/code&gt; interfaces
with &lt;code&gt;rustc&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
The relevant portion of the output is this:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
server.utilize({
                   use nickel::HttpRouter;
                   let mut router = ::nickel::Router::new();
                   {
                       router.get(&quot;**&quot;,
                                  {
                                      use nickel::{MiddlewareResult,
                                                   Responder, Response,
                                                   Request};
                                      #[inline(always)]
                                      fn restrict&amp;lt;&#39;a,
                                                  R: Responder&amp;gt;(r: R,
                                                                res:
                                                                    Response&amp;lt;&#39;a&amp;gt;)
                                       -&amp;gt; MiddlewareResult&amp;lt;&#39;a&amp;gt; {
                                          res.send(r)
                                      }
                                      #[inline(always)]
                                      fn restrict_closure&amp;lt;F&amp;gt;(f: F) -&amp;gt; F
                                       where F: for&amp;lt;&#39;r, &#39;b,
                                       &#39;a&amp;gt;Fn(&amp;amp;&#39;r mut Request&amp;lt;&#39;b, &#39;a, &#39;b&amp;gt;,
                                             Response&amp;lt;&#39;a&amp;gt;) -&amp;gt;
                                       MiddlewareResult&amp;lt;&#39;a&amp;gt; + Send +
                                       Sync {
                                          f
                                      }
                                      restrict_closure(move |_req, _res| {
                                                       restrict({
                                                                    do_log_time(logfile_path,
                                                                                auth_token)
                                                                }, _res)
                                                   })
                                  });
                       router
                   }
               });
&lt;/pre&gt;

&lt;p&gt;
Ok, so that&#39;s a lot to look at. Let us unpack it a little bit.
&lt;/p&gt;

&lt;p&gt;
There are two functions, &lt;code&gt;restrict&lt;/code&gt; and &lt;code&gt;restrict_closure&lt;/code&gt;, that
immediately surprise me. I &lt;i&gt;think&lt;/i&gt; they exist to provide better
type/error messaging about these request handling closures.
&lt;/p&gt;

&lt;p&gt;
However, what is even &lt;i&gt;more&lt;/i&gt; interesting is:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
restrict_closure(move |_req, _res| { ... })
&lt;/pre&gt;

&lt;p&gt;
&amp;#x2026; which tells me that macro is specify the closure as a move
closure &lt;i&gt;already&lt;/i&gt;. Well, there goes that theory.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-8&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-8&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;8&lt;/span&gt; Regrouping&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-8&quot;&gt;
&lt;p&gt;
Lets regroup and try to restate the problem.
At this point, I have a &lt;code&gt;main&lt;/code&gt; that looks like this:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
fn main() {
    let matches = App::new(&quot;simple-log&quot;).version(&quot;v0.0.1&quot;)
        .arg(Arg::with_name(&quot;LOG FILE&quot;)
             .short(&quot;l&quot;)
             .long(&quot;logfile&quot;)
             .required(true)
             .takes_value(true))
        .arg(Arg::with_name(&quot;AUTH TOKEN&quot;)
             .short(&quot;t&quot;)
             .long(&quot;token&quot;)
             .takes_value(true))
        .get_matches();

    let logfile_path = matches.value_of(&quot;LOG FILE&quot;).unwrap().to_string();
    let auth_token = match matches.value_of(&quot;AUTH TOKEN&quot;) {
        Some(str) =&amp;gt; Some(str.to_string()),
        None =&amp;gt; None
    };

    let mut server = Nickel::new();
    server.utilize(router! {
        get &quot;**&quot; =&amp;gt; |_req, _res| {
            do_log_time(logfile_path, auth_token)
        }
    });

    server.listen(&quot;127.0.0.1:6767&quot;);
}
&lt;/pre&gt;

&lt;p&gt;
Compiling gives me this:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo build
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:69:25: 69:37 error: cannot move out of captured outer variable in an `Fn` closure
src/main.rs:69             do_log_time(logfile_path, auth_token)
                                       ^~~~~~~~~~~~
&amp;lt;nickel macros&amp;gt;:1:1: 1:27 note: in expansion of as_block!
&amp;lt;nickel macros&amp;gt;:10:12: 10:42 note: expansion site
note: in expansion of closure expansion
&amp;lt;nickel macros&amp;gt;:9:6: 10:54 note: expansion site
&amp;lt;nickel macros&amp;gt;:1:1: 10:62 note: in expansion of _middleware_inner!
&amp;lt;nickel macros&amp;gt;:4:1: 4:60 note: expansion site
&amp;lt;nickel macros&amp;gt;:1:1: 7:46 note: in expansion of middleware!
&amp;lt;nickel macros&amp;gt;:11:32: 11:78 note: expansion site
&amp;lt;nickel macros&amp;gt;:1:1: 21:78 note: in expansion of _router_inner!
&amp;lt;nickel macros&amp;gt;:4:1: 4:43 note: expansion site
&amp;lt;nickel macros&amp;gt;:1:1: 4:47 note: in expansion of router!
src/main.rs:67:20: 71:6 note: expansion site
src/main.rs:69:39: 69:49 error: cannot move out of captured outer variable in an `Fn` closure
src/main.rs:69             do_log_time(logfile_path, auth_token)
                                                     ^~~~~~~~~~
&amp;lt;nickel macros&amp;gt;:1:1: 1:27 note: in expansion of as_block!
&amp;lt;nickel macros&amp;gt;:10:12: 10:42 note: expansion site
note: in expansion of closure expansion
&amp;lt;nickel macros&amp;gt;:9:6: 10:54 note: expansion site
&amp;lt;nickel macros&amp;gt;:1:1: 10:62 note: in expansion of _middleware_inner!
&amp;lt;nickel macros&amp;gt;:4:1: 4:60 note: expansion site
&amp;lt;nickel macros&amp;gt;:1:1: 7:46 note: in expansion of middleware!
&amp;lt;nickel macros&amp;gt;:11:32: 11:78 note: expansion site
&amp;lt;nickel macros&amp;gt;:1:1: 21:78 note: in expansion of _router_inner!
&amp;lt;nickel macros&amp;gt;:4:1: 4:43 note: expansion site
&amp;lt;nickel macros&amp;gt;:1:1: 4:47 note: in expansion of router!
src/main.rs:67:20: 71:6 note: expansion site
error: aborting due to 2 previous errors
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;



&lt;p&gt;
I asked about it on IRC, but I got no replies. Realistically, I should
have probably tried to ask on IRC during a time that I had more
patience, but it is what it is.
&lt;/p&gt;

&lt;p&gt;
I submitted an issue on
the &lt;code&gt;nickel.rs&lt;/code&gt; project, thinking that this was an issue with the
macro. This was the last idea I had &amp;#x2013; I &lt;i&gt;knew&lt;/i&gt; how likely
it was that I was wrong, but I saw no other way forward and I didn&#39;t
want to give up.
&lt;/p&gt;

&lt;p&gt;
And thus the issue at
&lt;a href=&quot;https://github.com/nickel-org/nickel.rs/issues/241&quot;&gt;https://github.com/nickel-org/nickel.rs/issues/241&lt;/a&gt; was born. Ryman
quickly saw
my mistake and was kind enough to help me through it. Sure enough, he
was right &amp;#x2013; if you&#39;re reading this Ryman, I owe you one.
&lt;/p&gt;

&lt;p&gt;
The problem occurred in the following specific closure. Let us examine
it to see what we can see:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
get &quot;**&quot; =&amp;gt; |_req, _res| {
    do_log_time(logfile_path, auth_token)
}
&lt;/pre&gt;

&lt;p&gt;
If you notice, here, the call to &lt;code&gt;do_log_time&lt;/code&gt; is
&lt;i&gt;transferring ownership&lt;/i&gt;
of &lt;code&gt;logfile_path&lt;/code&gt; and &lt;code&gt;auth_token&lt;/code&gt; to that invocation of that
function. This is where the problem is.
&lt;/p&gt;

&lt;p&gt;
To my untrained eye, this looks &quot;normal&quot;, the most natural form of the
code. There is an important caveat that I missed:
&lt;i&gt;in its current form, this lambda cannot be called more than once&lt;/i&gt;.
On the first time it is called, ownership of &lt;code&gt;logfile_path&lt;/code&gt; and
&lt;code&gt;auth_token&lt;/code&gt; are transferred to the invocation of
&lt;code&gt;do_log_time&lt;/code&gt;. Here&#39;s the thing: if this function is called again, it
&lt;i&gt;couldn&#39;t&lt;/i&gt; transfer ownership to &lt;code&gt;do_log_time&lt;/code&gt;, as it no longer owns
these two variables.
&lt;/p&gt;

&lt;p&gt;
Thus, we get the error message:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
src/main.rs:69:39: 69:49 error: cannot move out of captured outer variable in an `Fn` closure
&lt;/pre&gt;

&lt;p&gt;
I still don&#39;t think it makes any sense but now I understand at least
that it deals with moving ownership &quot;out&quot; from a closure.
&lt;/p&gt;

&lt;p&gt;
Anyway, the simplest way to fix this problem is to do:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
let mut server = Nickel::new();
server.utilize(router! {
    get &quot;**&quot; =&amp;gt; |_req, _res| {
        do_log_time(logfile_path.clone(), auth_token.clone())
    }
});
&lt;/pre&gt;

&lt;p&gt;
Now, upon each invocation, &lt;code&gt;logfile_path&lt;/code&gt; and &lt;code&gt;auth_token&lt;/code&gt; are still
owned, but clones are created and ownership of the clones is transferred.
&lt;/p&gt;

&lt;p&gt;
However, I&#39;d like to point out that I still believe this is a
sub-optimal solution. Since passing ownership is not referentially
transparent by definition, I&#39;m now leaning towards favoring the use of
references whenever possible.
&lt;/p&gt;

&lt;p&gt;
Would rust have been better if it used bare symbols to represent
borrowed references, but some other symbol for owned, say &lt;code&gt;*&lt;/code&gt;? I don&#39;t
know, but is an interesting question.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-9&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-9&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;9&lt;/span&gt; Refactoring&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-9&quot;&gt;
&lt;p&gt;
I&#39;m going to try a quick refactor to see if I can make things use
references. This is going to be interesting, because I might have some
unforeseen problems arise &amp;#x2013; we&#39;ll see!
&lt;/p&gt;

&lt;p&gt;
I&#39;ve been reading the Martin Fowler Refactoring book, and this has
renewed my appreciation for doing things in small steps at a
time. First, I want to change just one ownership transfer to a borrow;
lets start with &lt;code&gt;logfile_path&lt;/code&gt;. Starting with this:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
fn do_log_time(logfile_path: String, auth_token: Option&amp;lt;String&amp;gt;) -&amp;gt; String {
    match log_time(logfile_path) {
        Ok(entry) =&amp;gt; format!(&quot;Entry Logged: {}&quot;, entry),
        Err(e) =&amp;gt; format!(&quot;Error: {}&quot;, e)
    }
}

// ...

fn main() {
    // ...
    server.utilize(router! {
        get &quot;**&quot; =&amp;gt; |_req, _res| {
            do_log_time(logfile_path.clone(), auth_token.clone())
        }
    });
   // ...
}
&lt;/pre&gt;

&lt;p&gt;
I end up with this:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
fn do_log_time(logfile_path: &amp;amp;String, auth_token: Option&amp;lt;String&amp;gt;) -&amp;gt; String {
    match log_time(logfile_path.clone()) {
        Ok(entry) =&amp;gt; format!(&quot;Entry Logged: {}&quot;, entry),
        Err(e) =&amp;gt; format!(&quot;Error: {}&quot;, e)
    }
}

// ...

fn main() {
    // ...
    server.utilize(router! {
        get &quot;**&quot; =&amp;gt; |_req, _res| {
            do_log_time(&amp;amp;logfile_path, auth_token.clone())
        }
    });
   // ...
}
&lt;/pre&gt;

&lt;p&gt;
This refactoring might be called something like:
&lt;i&gt;replace ownership with borrow and clone&lt;/i&gt;. If I own something, and I
want to change this to a borrow, but I currently transfer ownership
somewhere else, I must create my own copy internally first. This
allows me to change my ownership to a borrow, and yet still transfer
ownership when I must. Of course, this involves cloning the
thing I borrowed, which duplicates memory and has performance costs,
but it allows me to change this line of code safely. I
can then keep replacing ownership with borrows without breaking
anything.
&lt;/p&gt;


&lt;p&gt;
Applying this a few more times gives me this code:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
use std::io::prelude::*;
use std::fs::OpenOptions;
use std::io;

#[macro_use] extern crate nickel;
use nickel::Nickel;

extern crate chrono;
use chrono::{DateTime,Local};

extern crate clap;
use clap::{App,Arg};

fn formatted_time_entry() -&amp;gt; String {
    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    let formatted = local.format(&quot;%a, %b %d %Y %I:%M:%S %p\n&quot;).to_string();
    formatted
}

fn record_entry_in_log(filename: &amp;amp;String, bytes: &amp;amp;[u8]) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let mut file = try!(OpenOptions::new().
                        append(true).
                        write(true).
                        create(true).
                        open(filename));
    try!(file.write_all(bytes));
    Ok(())
}

fn log_time(filename: &amp;amp;String) -&amp;gt; io::Result&amp;lt;String&amp;gt; {
    let entry = formatted_time_entry();
    {
        let bytes = entry.as_bytes();

        try!(record_entry_in_log(filename, &amp;amp;bytes));
    }
    Ok(entry)
}

fn do_log_time(logfile_path: &amp;amp;String, auth_token: &amp;amp;Option&amp;lt;String&amp;gt;) -&amp;gt; String {
    match log_time(logfile_path) {
        Ok(entry) =&amp;gt; format!(&quot;Entry Logged: {}&quot;, entry),
        Err(e) =&amp;gt; format!(&quot;Error: {}&quot;, e)
    }
}

fn main() {
    let matches = App::new(&quot;simple-log&quot;).version(&quot;v0.0.1&quot;)
        .arg(Arg::with_name(&quot;LOG FILE&quot;)
             .short(&quot;l&quot;)
             .long(&quot;logfile&quot;)
             .required(true)
             .takes_value(true))
        .arg(Arg::with_name(&quot;AUTH TOKEN&quot;)
             .short(&quot;t&quot;)
             .long(&quot;token&quot;)
             .takes_value(true))
        .get_matches();

    let logfile_path = matches.value_of(&quot;LOG FILE&quot;).unwrap().to_string();
    let auth_token = match matches.value_of(&quot;AUTH TOKEN&quot;) {
        Some(str) =&amp;gt; Some(str.to_string()),
        None =&amp;gt; None
    };

    let mut server = Nickel::new();
    server.utilize(router! {
        get &quot;**&quot; =&amp;gt; |_req, _res| {
            do_log_time(&amp;amp;logfile_path, &amp;amp;auth_token)
        }
    });

    server.listen(&quot;127.0.0.1:6767&quot;);

}
&lt;/pre&gt;

&lt;p&gt;
I&#39;m going to need to deal with &lt;code&gt;auth_token&lt;/code&gt; soon, but for now this is
a good place to stop.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id=&quot;outline-container-sec-10&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-10&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;10&lt;/span&gt; Conclusions &amp;amp; Retrospective on Part 4&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-10&quot;&gt;
&lt;p&gt;
The application now parses options. However, it was tremendously
difficult. I nearly ran out of options while trying solve my
problems. I would have been really frustrated if the issue on
nickel.rs wasn&#39;t resolved so helpfully.
&lt;/p&gt;

&lt;p&gt;
Some lessons:
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;Transferring ownership is a tricky thing. I think a new guideline
for me is to favor passing immutable borrows by default unless I
&lt;i&gt;must&lt;/i&gt; pass ownership for whatever reason.
&lt;/li&gt;

&lt;li&gt;Cargo &lt;i&gt;really&lt;/i&gt; should have an option to pass arbitrary &lt;code&gt;rustc&lt;/code&gt;
  arguments.
&lt;/li&gt;

&lt;li&gt;Some of the Rust error messages are still not very good.
&lt;/li&gt;

&lt;li&gt;Even if the error messages were poor, Rust was still right &amp;#x2013;
transferring ownership inside my closure &lt;i&gt;was&lt;/i&gt; an error, since the
function is called many times, once per web request. A lesson here
for me is: if
I don&#39;t understand an error message, it would be a good idea to
&lt;i&gt;think through&lt;/i&gt; the code, specifically looking what might be hard for
Rust to prove to be safe.
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
This experience also reinforces my frustration with compiled,
strong-typed programming languages. Sometimes, you really need to
examine things &lt;i&gt;in vivo&lt;/i&gt; in order to appreciate what is going
on. In this example, it was hard to create a minimal reproducible that
illustrated the problem.
&lt;/p&gt;

&lt;p&gt;
When error messages don&#39;t give you the information you need, you&#39;re
next best option is to start searching the Internet for information
related to the error message. This doesn&#39;t really give you the ability
to investigate, understand, and solve the problem yourself.
&lt;/p&gt;

&lt;p&gt;
I think this could be alleviated by adding some ability to interrogate
the state of the compiler at different times, to find more information
about the problem. Something like opening an interactive prompt on
compile errors would be really great, but even annotating the code to
request detailed information from the compiler would be extremely useful.
&lt;/p&gt;


&lt;p&gt;
&amp;#x2014;
&lt;/p&gt;

&lt;p&gt;
I wrote this post over the course of about a month, mostly because I
was so busy dealing with house buying stuff. At times, I was
&lt;i&gt;extremely&lt;/i&gt; frustrated with some of this. I expected integrating
option parsing to be the easiest of tasks!
&lt;/p&gt;

&lt;p&gt;
However, realizing that Rust caught my bug really relieving. Even if
the error message wasn&#39;t as good as I had hoped, I liked that this
would have been a legitimate segmentation fault that I was saved
from.
&lt;/p&gt;

&lt;p&gt;
I hope that as Rust matures, the error messages get better. If they
do, I think all my concerns will disappear.
&lt;/p&gt;



&lt;p&gt;
&amp;#x2014;
&lt;/p&gt;

&lt;p&gt;
Series: A Simple Web App in Rust
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-1/&quot;&gt;Part 1&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-2a/&quot;&gt;Part 2a&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-2b/&quot;&gt;Part 2b&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-3/&quot;&gt;Part 3&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-4-cli-option-parsing/&quot;&gt;Part 4&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-conclusion/&quot;&gt;Conclusion&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 08 Aug 2015 00:00:00 -0400</pubDate>
        <link>http://joelmccracken.github.io//entries/a-simple-web-app-in-rust-pt-4-cli-option-parsing/</link>
        <guid isPermaLink="true">http://joelmccracken.github.io//entries/a-simple-web-app-in-rust-pt-4-cli-option-parsing/</guid>
      </item>
    
      <item>
        <title>A Simple Web App in Rust, Part 3 -- Integration</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. Previously&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1&quot;&gt;1.1. Review&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-2&quot;&gt;2. Combining the Code: Fisticuffing with the Type System&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-3&quot;&gt;3. Fin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; Previously&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
This is the third part in a series on writing a very simple web
application in Rust.
&lt;/p&gt;

&lt;p&gt;
So far, we have the the pieces for an MVP in separate rust
files. Here, we want to put them together into a single app.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.1&lt;/span&gt; Review&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;
&lt;p&gt;
We have the following two pieces to put together: the file
writing/logging
code, and the serving code. Lets review each of them.
&lt;/p&gt;

&lt;p&gt;
First, the logging code:
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
extern crate chrono;

use std::io::prelude::*;
use std::fs::{File,OpenOptions};
use std::io;
use chrono::{DateTime,Local};


fn formatted_time_entry() -&amp;gt; String {
    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    let formatted = local.format(&quot;%a, %b %d %Y %I:%M:%S %p\n&quot;).to_string();
    formatted
}

fn record_entry_in_log(filename: &amp;amp;str, bytes: &amp;amp;[u8]) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let mut file = try!(OpenOptions::new().
                        append(true).
                        write(true).
                        create(true).
                        open(filename));
    try!(file.write_all(bytes));
    Ok(())
}

fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let entry = formatted_time_entry();
    let bytes = entry.as_bytes();

    try!(record_entry_in_log(filename, &amp;amp;bytes));
    Ok(())
}

fn main() {
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(e) =&amp;gt; println!(&quot;Error: {}&quot;, e)
    }
}
&lt;/pre&gt;


&lt;p&gt;
Now, the serving code:
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
#[macro_use] extern crate nickel;

use nickel::Nickel;

fn say_hello() -&amp;gt; &amp;amp;&#39;static str {
    &quot;Hello dear world!&quot;
}

fn main() {
    let mut server = Nickel::new();

    server.utilize(router! {
        get &quot;**&quot; =&amp;gt; |_req, _res| {
            say_hello()
        }
    });

    server.listen(&quot;127.0.0.1:6767&quot;);
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;2&lt;/span&gt; Combining the Code: Fisticuffing with the Type System&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;
&lt;p&gt;
So, I want to combine these two programs.
First, I&#39;ll put them both into the same
file (and change the name of one of the &lt;code&gt;main&lt;/code&gt; functions, of course)
to see if they all compile together.
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
#[macro_use] extern crate nickel;
extern crate chrono;

use std::io::prelude::*;
use std::fs::{File,OpenOptions};
use std::io;
use chrono::{DateTime,Local};

use nickel::Nickel;

fn formatted_time_entry() -&amp;gt; String {
    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    let formatted = local.format(&quot;%a, %b %d %Y %I:%M:%S %p\n&quot;).to_string();
    formatted
}

fn record_entry_in_log(filename: &amp;amp;str, bytes: &amp;amp;[u8]) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let mut file = try!(OpenOptions::new().
                        append(true).
                        write(true).
                        create(true).
                        open(filename));
    try!(file.write_all(bytes));
    Ok(())
}

fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let entry = formatted_time_entry();
    let bytes = entry.as_bytes();

    try!(record_entry_in_log(filename, &amp;amp;bytes));
    Ok(())
}

fn main2() {
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(e) =&amp;gt; println!(&quot;Error: {}&quot;, e)
    }
}


fn say_hello() -&amp;gt; &amp;amp;&#39;static str {
    &quot;Hello dear world!&quot;
}

fn main() {
    let mut server = Nickel::new();

    server.utilize(router! {
        get &quot;**&quot; =&amp;gt; |_req, _res| {
            say_hello()
        }
    });

    server.listen(&quot;127.0.0.1:6767&quot;);
}
&lt;/pre&gt;

&lt;p&gt;
Compiling &amp;amp; Running:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
src/main.rs:5:15: 5:19 warning: unused import, #[warn(unused_imports)] on by default
src/main.rs:5 use std::fs::{File,OpenOptions};
                            ^~~~
src/main.rs:11:1: 15:2 warning: function is never used: `formatted_time_entry`, #[warn(dead_code)] o
n by default
src/main.rs:11 fn formatted_time_entry() -&amp;gt; String {
src/main.rs:12     let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
src/main.rs:13     let formatted = local.format(&quot;%a, %b %d %Y %I:%M:%S %p\n&quot;).to_string();
src/main.rs:14     formatted
src/main.rs:15 }
src/main.rs:17:1: 25:2 warning: function is never used: `record_entry_in_log`, #[warn(dead_code)] on
 by default
src/main.rs:17 fn record_entry_in_log(filename: &amp;amp;str, bytes: &amp;amp;[u8]) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
src/main.rs:18     let mut file = try!(OpenOptions::new().
src/main.rs:19                         append(true).
src/main.rs:20                         write(true).
src/main.rs:21                         create(true).
src/main.rs:22                         open(filename));
               ...
src/main.rs:27:1: 33:2 warning: function is never used: `log_time`, #[warn(dead_code)] on by default
src/main.rs:27 fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
src/main.rs:28     let entry = formatted_time_entry();
src/main.rs:29     let bytes = entry.as_bytes();
src/main.rs:30
src/main.rs:31     try!(record_entry_in_log(filename, &amp;amp;bytes));
src/main.rs:32     Ok(())
               ...
src/main.rs:35:1: 40:2 warning: function is never used: `main2`, #[warn(dead_code)] on by default
src/main.rs:35 fn main2() {
src/main.rs:36     match log_time(&quot;log.txt&quot;) {
src/main.rs:37         Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
src/main.rs:38         Err(e) =&amp;gt; println!(&quot;Error: {}&quot;, e)
src/main.rs:39     }
src/main.rs:40 }
     Running `target/debug/simple-log`
Listening on http://127.0.0.1:6767
Ctrl-C to shutdown server
&lt;/pre&gt;

&lt;p&gt;
Cool. I totally expected those dead-code warning messages, and visiting
&lt;code&gt;localhost:6767&lt;/code&gt; in my browser still renders a &quot;hello, world&quot; page.
&lt;/p&gt;

&lt;p&gt;
Here&#39;s an attempt to integrate them:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
#[macro_use] extern crate nickel;
extern crate chrono;

use std::io::prelude::*;
use std::fs::{File,OpenOptions};
use std::io;
use chrono::{DateTime,Local};

use nickel::Nickel;

fn formatted_time_entry() -&amp;gt; String {
    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    let formatted = local.format(&quot;%a, %b %d %Y %I:%M:%S %p\n&quot;).to_string();
    formatted
}

fn record_entry_in_log(filename: &amp;amp;str, bytes: &amp;amp;[u8]) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let mut file = try!(OpenOptions::new().
                        append(true).
                        write(true).
                        create(true).
                        open(filename));
    try!(file.write_all(bytes));
    Ok(())
}

fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let entry = formatted_time_entry();
    let bytes = entry.as_bytes();

    try!(record_entry_in_log(filename, &amp;amp;bytes));
    Ok(())
}

fn do_log_time() -&amp;gt; &amp;amp;&#39;static str {
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(e) =&amp;gt; println!(&quot;Error: {}&quot;, e)
    }
}

fn main() {
    let mut server = Nickel::new();

    server.utilize(router! {
        get &quot;**&quot; =&amp;gt; |_req, _res| {
            do_log_time()
        }
    });

    server.listen(&quot;127.0.0.1:6767&quot;);
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:37:19: 37:44 error: mismatched types:
 expected `&amp;amp;&#39;static str`,
    found `()`
(expected &amp;amp;-ptr,
    found ()) [E0308]
src/main.rs:37         Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~
src/main.rs:38:19: 38:43 error: mismatched types:
 expected `&amp;amp;&#39;static str`,
    found `()`
(expected &amp;amp;-ptr,
    found ()) [E0308]
src/main.rs:38         Err(e) =&amp;gt; println!(&quot;Error: {}&quot;, e)
                                 ^~~~~~~~~~~~~~~~~~~~~~~~
error: aborting due to 2 previous errors
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
The macro &lt;code&gt;println!&lt;/code&gt; here is writing to standard out, but what I want is
something that will be returning a string. Is there a &lt;code&gt;sprintln!&lt;/code&gt;, or
something equivalent?
&lt;/p&gt;

&lt;p&gt;
Doing a quick search, it looks like the answer is &lt;code&gt;format!&lt;/code&gt;:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
#[macro_use] extern crate nickel;
extern crate chrono;

use std::io::prelude::*;
use std::fs::{File,OpenOptions};
use std::io;
use chrono::{DateTime,Local};

use nickel::Nickel;

fn formatted_time_entry() -&amp;gt; String {
    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    let formatted = local.format(&quot;%a, %b %d %Y %I:%M:%S %p\n&quot;).to_string();
    formatted
}

fn record_entry_in_log(filename: &amp;amp;str, bytes: &amp;amp;[u8]) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let mut file = try!(OpenOptions::new().
                        append(true).
                        write(true).
                        create(true).
                        open(filename));
    try!(file.write_all(bytes));
    Ok(())
}

fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let entry = formatted_time_entry();
    let bytes = entry.as_bytes();

    try!(record_entry_in_log(filename, &amp;amp;bytes));
    Ok(())
}

fn do_log_time() -&amp;gt; &amp;amp;&#39;static str {
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; format!(&quot;File created!&quot;),
        Err(e) =&amp;gt; format!(&quot;Error: {}&quot;, e)
    }
}

fn main() {
    let mut server = Nickel::new();

    server.utilize(router! {
        get &quot;**&quot; =&amp;gt; |_req, _res| {
            do_log_time()
        }
    });

    server.listen(&quot;127.0.0.1:6767&quot;);
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:37:19: 37:43 error: mismatched types:
 expected `&amp;amp;&#39;static str`,
    found `collections::string::String`
(expected &amp;amp;-ptr,
    found struct `collections::string::String`) [E0308]
src/main.rs:37         Ok(..) =&amp;gt; format!(&quot;File created!&quot;),
                                 ^~~~~~~~~~~~~~~~~~~~~~~~
src/main.rs:38:19: 38:42 error: mismatched types:
 expected `&amp;amp;&#39;static str`,
    found `collections::string::String`
(expected &amp;amp;-ptr,
    found struct `collections::string::String`) [E0308]
src/main.rs:38         Err(e) =&amp;gt; format!(&quot;Error: {}&quot;, e)
                                 ^~~~~~~~~~~~~~~~~~~~~~~
error: aborting due to 2 previous errors
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
So, I know there&#39;s a way to convert between a &lt;code&gt;String&lt;/code&gt; and an
&lt;code&gt;&amp;amp;str&lt;/code&gt;&amp;#x2026; hmm. I recall that I can use an &lt;code&gt;&amp;amp;&lt;/code&gt;.
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
fn do_log_time() -&amp;gt; &amp;amp;&#39;static str {
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; &amp;amp;format!(&quot;File created!&quot;),
        Err(e) =&amp;gt; &amp;amp;format!(&quot;Error: {}&quot;, e)
    }
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:37:20: 37:44 error: borrowed value does not live long enough
src/main.rs:37         Ok(..) =&amp;gt; &amp;amp;format!(&quot;File created!&quot;),
                                  ^~~~~~~~~~~~~~~~~~~~~~~~
note: reference must be valid for the static lifetime...
src/main.rs:37:19: 37:44 note: ...but borrowed value is only valid for the expression at 37:18
src/main.rs:37         Ok(..) =&amp;gt; &amp;amp;format!(&quot;File created!&quot;),
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~
src/main.rs:38:20: 38:43 error: borrowed value does not live long enough
src/main.rs:38         Err(e) =&amp;gt; &amp;amp;format!(&quot;Error: {}&quot;, e)
                                  ^~~~~~~~~~~~~~~~~~~~~~~
note: reference must be valid for the static lifetime...
src/main.rs:38:19: 38:43 note: ...but borrowed value is only valid for the expression at 38:18
src/main.rs:38         Err(e) =&amp;gt; &amp;amp;format!(&quot;Error: {}&quot;, e)
                                 ^~~~~~~~~~~~~~~~~~~~~~~~
error: aborting due to 2 previous errors
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
This thing again. I think I&#39;m going to need a block here:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
fn do_log_time() -&amp;gt; &amp;amp;&#39;static str {
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; {
            let fmt = format!(&quot;File created!&quot;);
            &amp;amp;fmt
        },
        Err(e) =&amp;gt; {
            let fmt = format!(&quot;Error: {}&quot;, e);
            &amp;amp;fmt
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:39:14: 39:17 error: `fmt` does not live long enough
src/main.rs:39             &amp;amp;fmt
                            ^~~
note: reference must be valid for the static lifetime...
src/main.rs:38:48: 40:10 note: ...but borrowed value is only valid for the block suffix following s
tatement 0 at 38:47
src/main.rs:38             let fmt = format!(&quot;File created!&quot;);
src/main.rs:39             &amp;amp;fmt
src/main.rs:40         },
src/main.rs:43:14: 43:17 error: `fmt` does not live long enough
src/main.rs:43             &amp;amp;fmt
                            ^~~
note: reference must be valid for the static lifetime...
src/main.rs:42:47: 44:10 note: ...but borrowed value is only valid for the block suffix following s
tatement 0 at 42:46
src/main.rs:42             let fmt = format!(&quot;Error: {}&quot;, e);
src/main.rs:43             &amp;amp;fmt
src/main.rs:44         }
error: aborting due to 2 previous errors
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
That didn&#39;t work. I think the problem is that &lt;code&gt;fmt&lt;/code&gt; only exists for
that new block, but the return value  is used outside of it. What if I
promote &lt;code&gt;fmt&lt;/code&gt; to the top of the function?
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
fn do_log_time() -&amp;gt; &amp;amp;&#39;static str {
    let mut fmt = &quot;&quot;.to_string();
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; {
            fmt = format!(&quot;File created!&quot;);
            &amp;amp;fmt
        },
        Err(e) =&amp;gt; {
            fmt = format!(&quot;Error: {}&quot;, e);
            &amp;amp;fmt
        }
    }

}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:40:14: 40:17 error: `fmt` does not live long enough
src/main.rs:40             &amp;amp;fmt
                            ^~~
note: reference must be valid for the static lifetime...
src/main.rs:36:34: 48:2 note: ...but borrowed value is only valid for the block suffix following st
atement 0 at 36:33
src/main.rs:36     let mut fmt = &quot;&quot;.to_string();
src/main.rs:37     match log_time(&quot;log.txt&quot;) {
src/main.rs:38         Ok(..) =&amp;gt; {
src/main.rs:39             fmt = format!(&quot;File created!&quot;);
src/main.rs:40             &amp;amp;fmt
src/main.rs:41         },
               ...
src/main.rs:44:14: 44:17 error: `fmt` does not live long enough
src/main.rs:44             &amp;amp;fmt
                            ^~~
note: reference must be valid for the static lifetime...
src/main.rs:36:34: 48:2 note: ...but borrowed value is only valid for the block suffix following st
atement 0 at 36:33
src/main.rs:36     let mut fmt = &quot;&quot;.to_string();
src/main.rs:37     match log_time(&quot;log.txt&quot;) {
src/main.rs:38         Ok(..) =&amp;gt; {
src/main.rs:39             fmt = format!(&quot;File created!&quot;);
src/main.rs:40             &amp;amp;fmt
src/main.rs:41         },
               ...
error: aborting due to 2 previous errors
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
I don&#39;t know how to fix this. I&#39;m going to just set this down, for
now, and come back to it later.
&lt;/p&gt;

&lt;p&gt;
&amp;#x2014;
&lt;/p&gt;

&lt;p&gt;
I&#39;ve tried a few new things, and nothing works. I think I need to
learn more of how this ownership/lifetime stuff works.
&lt;/p&gt;

&lt;p&gt;
I just read a bit of the Rust book, and I notice this note:
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
We choose the &lt;code&gt;String&lt;/code&gt; type for the name, rather than
&lt;code&gt;&amp;amp;str&lt;/code&gt;. Generally speaking, working with a type which owns its data is
easier than working with one that uses references.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
Because I&#39;m in &quot;do&quot; mode and not &quot;learn&quot; mode, I want to try using
&lt;code&gt;String&lt;/code&gt; to see if that works.
&lt;/p&gt;

&lt;p&gt;
Now:
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
fn do_log_time() -&amp;gt; String {
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; format!(&quot;File created!&quot;),
        Err(e) =&amp;gt; format!(&quot;Error: {}&quot;, e)
    }
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
     Running `target/debug/simple-log`
Listening on http://127.0.0.1:6767
Ctrl-C to shutdown server
&lt;/pre&gt;

&lt;p&gt;
It worked. Visiting the page in a browser shows &quot;File created!&quot;,
and it also wrote an entry to the log file.
&lt;/p&gt;

&lt;p&gt;
I&#39;m not really surprised that this works &amp;#x2013; I kinda figured the
solution would be to return a &lt;code&gt;String&lt;/code&gt; instead of an &lt;code&gt;&amp;amp;str&lt;/code&gt;, but I
wanted to take it as a challenge to figure out.
&lt;/p&gt;

&lt;p&gt;
Now that I think about it, this makes sense. I&#39;m trying to
return a borrowed reference, but I also own it, so returning it
wouldn&#39;t make any sense. How would I return an &lt;code&gt;&amp;amp;str&lt;/code&gt; that I created
in my own function? I haven&#39;t seen anything using a plain, not-borrowed &quot;&lt;code&gt;str&lt;/code&gt;&quot;
anywhere.
&lt;/p&gt;

&lt;p&gt;
I this absence of not-borrowed ~&amp;amp;str~s has to do with it representing being a plain
c string pointer. This
must have some complications that I&#39;m not aware of, and for it to
play nicely with Rust it must interface with rust the normal
Rust rules sharing ownership must apply.
&lt;/p&gt;

&lt;p&gt;
If some other part of the program has knowledge of an array of bytes,
and provides me with a reference to that array, what does that mean?
Are &lt;code&gt;&amp;amp;str&lt;/code&gt; types basically just so that C strings can be referenced
without some additional metadata associated with them?
&lt;/p&gt;

&lt;p&gt;
The Rust book says &lt;code&gt;&amp;amp;str&lt;/code&gt; -&amp;gt; &lt;code&gt;String&lt;/code&gt; has some cost. I wonder if this
always true, or only for static program strings. Would a
heap-allocated &lt;code&gt;&amp;amp;str&lt;/code&gt; require copying for a &lt;code&gt;String&lt;/code&gt;? Now that I
think about it, I bet the answer is yes; if you want to convert
a borrowed value into something that is owned, the only
reasonable solution would be to copy it.
&lt;/p&gt;

&lt;p&gt;
Anyway, I think I just want to move on. I think the answer is that
what I was trying to do just didn&#39;t make sense, and Rust correctly
stopped me. I do wish I understood why every &lt;code&gt;str&lt;/code&gt; is borrowed,
though.
&lt;/p&gt;

&lt;p&gt;
I&#39;m going to try to return the logged time string from &lt;code&gt;log_time&lt;/code&gt; and
have that displayed to the user. My first attempt:
&lt;/p&gt;


&lt;pre class=&quot;example&quot;&gt;
fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;String&amp;gt; {
    let entry = formatted_time_entry();
    let bytes = entry.as_bytes();

    try!(record_entry_in_log(filename, &amp;amp;bytes));
    Ok(entry)
}

fn do_log_time() -&amp;gt; String {
    match log_time(&quot;log.txt&quot;) {
        Ok(entry) =&amp;gt; format!(&quot;Entry Logged: {}&quot;, entry),
        Err(e) =&amp;gt; format!(&quot;Error: {}&quot;, e)
    }
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:32:8: 32:13 error: cannot move out of `entry` because it is borrowed
src/main.rs:32     Ok(entry)
                      ^~~~~
src/main.rs:29:17: 29:22 note: borrow of `entry` occurs here
src/main.rs:29     let bytes = entry.as_bytes();
                               ^~~~~
error: aborting due to previous error
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
Hmm. So I guess that makes sense&amp;#x2026; &lt;code&gt;bytes&lt;/code&gt; &quot;borrows&quot; the contents of
&lt;code&gt;entry&lt;/code&gt;. And, since this value is still borrowed by the time
&lt;code&gt;OK(entry)&lt;/code&gt; is called, this causes the error.
&lt;/p&gt;

&lt;p&gt;
This works:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;String&amp;gt; {
    let entry = formatted_time_entry();
    {
        let bytes = entry.as_bytes();

        try!(record_entry_in_log(filename, &amp;amp;bytes));
    }
    Ok(entry)
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run &amp;amp;
[1] 66858
$      Running `target/debug/simple-log`
Listening on http://127.0.0.1:6767
Ctrl-C to shutdown server

$ curl localhost:6767
Entry Logged: Tue, Jun 23 2015 12:34:19 AM
&lt;/pre&gt;

&lt;p&gt;
This isn&#39;t the first time I&#39;ve used the &quot;stick a new block
here&quot; feature, but it does seem to work for this, and it seems like a
reasonably elegant way to handle this. My first thought though was
that I needed to call another function to somehow &quot;convert&quot; bytes back
into a &lt;code&gt;String&lt;/code&gt;, but then I realized that this didn&#39;t actually make
sense, and I needed to &quot;deallocate&quot; the borrow, somehow.
&lt;/p&gt;

&lt;p&gt;
I don&#39;t understand what &quot;move out of `entry`&quot; means in that error message
though. I&#39;m thinking that you can&#39;t transfer ownership of a value as
long as there is a borrowed reference to it, too. But maybe
that isn&#39;t actually true. Is sending it to &lt;code&gt;Ok()&lt;/code&gt; changing it? I&#39;m
pretty confused by this, and the Rust book doesn&#39;t seem to address
this specific issue, but I think this must be it &amp;#x2013; ownership can&#39;t be
changed while a borrow exists. I think.
&lt;/p&gt;

&lt;p&gt;
Its nice to see that as I&#39;ve been browsing through the Rust book
section on borrowing, using a block is the cited solution to this
problem.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;3&lt;/span&gt; Fin&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;
&lt;p&gt;
Integrating this was much harder than I
expected. Borrowing/ownership got me a few times here, so I&#39;m going to
cut it at this point, since this has gotten pretty long.
&lt;/p&gt;

&lt;p&gt;
Fortunately, I think I am slowly understanding how Rust works, and
especially its borrowing functionality. This gives me hope for the
future.
&lt;/p&gt;

&lt;p&gt;
&amp;#x2014;
&lt;/p&gt;

&lt;p&gt;
Series: A Simple Web App in Rust
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-1/&quot;&gt;Part 1&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-2a/&quot;&gt;Part 2a&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-2b/&quot;&gt;Part 2b&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-3/&quot;&gt;Part 3&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-4-cli-option-parsing/&quot;&gt;Part 4&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-conclusion/&quot;&gt;Conclusion&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 04 Jul 2015 00:00:00 -0400</pubDate>
        <link>http://joelmccracken.github.io//entries/a-simple-web-app-in-rust-pt-3/</link>
        <guid isPermaLink="true">http://joelmccracken.github.io//entries/a-simple-web-app-in-rust-pt-3/</guid>
      </item>
    
      <item>
        <title>Rust, the Language for Growth</title>
        <description>&lt;p&gt;
The most important feature that attracts me to Rust is its focus
on allowing the language to &lt;i&gt;grow&lt;/i&gt;.
&lt;/p&gt;

&lt;p&gt;
If Rust was going to remain static as it currently exists, I would
probably have avoided it and chosen a different language to spend my
time with, such as OCaml, Haskell, or Racket.
&lt;/p&gt;

&lt;p&gt;
My two main concerns regarding code, and what influences the things I
study, are:
&lt;/p&gt;

&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;How fast will I be able to go from idea to implementation?
&lt;/li&gt;

&lt;li&gt;How maintainable will the code be? Will I be able to make changes
easily?
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
However, Rust brings me the following benefits:
&lt;/p&gt;

&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;Control of the hardware. I learned C
as a student ages ago by reading K&amp;amp;R, and I know that for me to write
production-quality C would require lots of ramp up time.
&lt;/li&gt;

&lt;li&gt;Speed. Even if my naive code isn&#39;t as fast as it could be, I feel
reasonably sure that I can make whatever speed improvements I need
without making the code unreasonably eldritch.
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
These sets of benefits don&#39;t intersect. So, why am I interested in Rust?
&lt;/p&gt;

&lt;p&gt;
I see Rust as a starting point, a point from which other,
higher level abstractions can be added. I have heard numerous times
that features like garbage collection will be added after the fact, and
that this is can be implemented as user-land libraries. Indeed, much
of what would normally be in the standard library is being put into crates,
allowing libraries to grow independent of Rust itself.
&lt;/p&gt;

&lt;p&gt;
Racket, in contrast, is an amazing system for
exploring and implementing new ideas in syntax, semantics,
and abstraction. However, its runtime and base system mean that it is
suitable for a relatively select domain of problems. These domains
have large, established language communities (Ruby, Python) that are
losing mind share &lt;i&gt;because of these limitations, not because of a lack
of expressiveness&lt;/i&gt; in those languages.
&lt;/p&gt;

&lt;p&gt;
Because of these considerations, Rust is a good base language that can
grow into the future. Its focus on not making trade-offs that preclude
certain programming domains means that we can use it to starting
building &lt;i&gt;better&lt;/i&gt; systems, be they applications, operating systems, or
new programming languages with a restricted domain of applicability.
&lt;/p&gt;
</description>
        <pubDate>Sun, 28 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://joelmccracken.github.io//entries/rust-the-language-for-growth/</link>
        <guid isPermaLink="true">http://joelmccracken.github.io//entries/rust-the-language-for-growth/</guid>
      </item>
    
      <item>
        <title>Dealing With the Rust Shift in Perspective</title>
        <description>&lt;p&gt;
There is a famous quote by Alan Kay:
&lt;/p&gt;

&lt;p&gt;
&quot;Perspective is worth 80 IQ points.&quot;
&lt;/p&gt;

&lt;p&gt;
I have seen this happen over and over again. A change in perspective
becomes popular, and the industry begins to adopt it.
&lt;/p&gt;

&lt;p&gt;
I have witnessed the following shifts:
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;The shift from object-oriented to functional programming. We may be
seeing another shift towards relational/logic programming, but that is
still a long way off.
&lt;/li&gt;

&lt;li&gt;Reactive programming is becoming more popular. This may be seen
in functional reactive programming and evented programming.
&lt;/li&gt;

&lt;li&gt;Memory management: Should memory allocation/deallocation be managed
by the programmer? By a run-time analyzer that determines when
memory is safe to be reclaimed? Or can memory usage be understood at
compile-time, and managed safely?
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
This last point is what Rust specifically is addressing. By making
memory usage something that is statically analyzable,
an entire class of memory issues disappear.
&lt;/p&gt;

&lt;p&gt;
You can always tell when a perspective shift is happening. It requires
you to change how you think about problems, often in a way that is
uncomfortable and frustrating. Tasks that used to be easy may now
require a lot of effort, at least until you learn how to think in a
new way. Also, the story of people who learn this new way of thinking
is always the same: &quot;It was hard for a while, but eventually I got it,
and now it comes naturally!&quot;
&lt;/p&gt;

&lt;p&gt;
Paul Graham mentions in &lt;a href=&quot;http://www.paulgraham.com/avg.html&quot;&gt;one of his essays&lt;/a&gt; that a programmer who
doesn&#39;t understand how to
think with a certain feature also won&#39;t see its value, and will think
it isn&#39;t useful. I think this is quite true. I once could not
understand the
value of anonymous functions and closures, but now I can&#39;t program
without them.
&lt;/p&gt;

&lt;p&gt;
The key is to push through this hard time. I think reading the
experiences of others who have already worked through the pain may be
enough motivation to get you through.
&lt;/p&gt;

&lt;p&gt;
Ultimately, I don&#39;t know if I will like dealing with memory in the
Rust way. It may be that I don&#39;t. But I do know that I can&#39;t judge it
properly until I&#39;ve come through to the other side and gained the
understanding of how to use it well. I &lt;i&gt;bet&lt;/i&gt; that I will want to keep
using garbage collection, but Rust will be my choice when this GC
isn&#39;t feasible or possible.
&lt;/p&gt;
</description>
        <pubDate>Sat, 20 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://joelmccracken.github.io//entries/dealing-with-the-rust-shift-in-perspective/</link>
        <guid isPermaLink="true">http://joelmccracken.github.io//entries/dealing-with-the-rust-shift-in-perspective/</guid>
      </item>
    
      <item>
        <title>A Simple Web App in Rust, Part 2b</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. The Series&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-2&quot;&gt;2. Using Chrono&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-3&quot;&gt;3. Writing the Date/Time to a File&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-4&quot;&gt;4. Building a File Logger&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-4-1&quot;&gt;4.1. Misunderstanding &lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-4-2&quot;&gt;4.2. Filling in Missing Pieces&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-5&quot;&gt;5. Conclusion &amp;amp; Next Steps&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; The Series&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
This is a post in a series of me writing down my experience as I try to
build a simple web app in Rust.
&lt;/p&gt;

&lt;p&gt;
So far, we have:
&lt;/p&gt;

&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-1/&quot;&gt;Defined the goal &amp;amp; Written a &quot;Hello World&quot; web server&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-2a/&quot;&gt;Figured out how to write to a file&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
The last part was especially harrowing. This piece will be to
investigate date/time formatting in Rust, with a focus on writing
visiting time in a nice format.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;2&lt;/span&gt; Using Chrono&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;
&lt;p&gt;
So, searching for &quot;date&quot; on crates.io shows
&lt;a href=&quot;https://crates.io/search?q=date&quot;&gt;one prominent result&lt;/a&gt;,
namely the crate &quot;chrono&quot;. This looks very popular, and was updated
very recently, so it looks like a good candidate. A look through the
README seems to show that it has decent date/time pretty printing functionality.
&lt;/p&gt;

&lt;p&gt;
The first thing would be to add the Chrono requirement line to
&lt;code&gt;Cargo.toml&lt;/code&gt;, but first let&#39;s move the old &lt;code&gt;main.rs&lt;/code&gt; out of the way so
that there is a new place to experiment:
&lt;/p&gt;


&lt;pre class=&quot;example&quot;&gt;
$ ls
Cargo.lock Cargo.toml log.txt    src        target
$ cd src/
$ ls
main.rs     web_main.rs
$ git mv main.rs main_file_writing.rs
$ touch main.rs
$ git add main.rs
$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

        modified:   main.rs
        copied:     main.rs -&amp;gt; main_file_writing.rs

Untracked files:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed)

        ../log.txt

$ git commit -m &#39;move file writing out of the way for working with dates&#39;
[master 4cd2b0e] move file writing out of the way for working with dates
 2 files changed, 16 deletions(-)
 rewrite src/main.rs (100%)
 copy src/{main.rs =&amp;gt; main_file_writing.rs} (100%)
&lt;/pre&gt;

&lt;p&gt;
Adding the dependency on Chrono to &lt;code&gt;Cargo.toml&lt;/code&gt;:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
[package]
name = &quot;simple-log&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Joel McCracken &amp;lt;mccracken.joel@gmail.com&amp;gt;&quot;]

[dependencies]

chrono = &quot;0.2&quot;

[dependencies.nickel]

git = &quot;https://github.com/nickel-org/nickel.rs.git&quot;
&lt;/pre&gt;


&lt;p&gt;
The readme says this next:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
And put this in your crate root:

    extern crate chrono;
&lt;/pre&gt;

&lt;p&gt;
I don&#39;t know what this means, but I&#39;m just going to try to put it on
top of &lt;code&gt;main.rs&lt;/code&gt; because it looks like Rust code:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
extern crate chrono;

fn main() { }
&lt;/pre&gt;

&lt;p&gt;
compiling:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading num v0.1.25
 Downloading rand v0.3.8
 Downloading chrono v0.2.14
   Compiling rand v0.3.8
   Compiling num v0.1.25
   Compiling chrono v0.2.14
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
     Running `/Users/joel/Projects/simple-log/target/debug/simple-log`
&lt;/pre&gt;

&lt;p&gt;
So, it looks like it downloaded Chrono, compiled successfully, and
exited. Rad. I think the next step would be to try to use it. Based
upon the first example listed, I have this:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
extern crate chrono;
use chrono::*;

fn main() {
    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    println!(&#39;{}&#39;, local);
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
main.rs:6:14: 6:16 error: unterminated character constant: &#39;{
main.rs:6     println!(&#39;{}&#39;, local);
                       ^~
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
&amp;#x2026;? After I look at this for a second, I think its telling me that I
need to use double quotes, not single quotes. which makes some sense,
since single quotes are used in lifetime specifications.
&lt;/p&gt;

&lt;p&gt;
After switching from single to double quotes:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
     Running `/Users/joel/Projects/simple-log/target/debug/simple-log`
2015-06-05 16:54:47.483088 -04:00
&lt;/pre&gt;

&lt;p&gt;
&amp;#x2026; &lt;i&gt;whoa&lt;/i&gt;. That was easy. It looks like &lt;code&gt;println!&lt;/code&gt; has some kind of
interface for whatever is being printed and can print many different
things.
&lt;/p&gt;

&lt;p&gt;
There is some irony here. So far, I was able to generate a simple
hello world web application and print a well-formatted date and time
with really very little effort, but writing to a file cost me dearly
in time. I&#39;m not sure what the lesson is, here. I think it is clear
that the rust community has gone through great effort to make their
packages nice to work with, even if the language is still hard to use
(for me).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;3&lt;/span&gt; Writing the Date/Time to a File&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;
&lt;p&gt;
I think the next sensible task would be to actually write this string
to a file, and for this, I want to look at what I ended up with in the
last entry:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cat main_file_writing.rs
use std::io::prelude::*;
use std::fs::File;
use std::io;

fn log_something(filename: &amp;amp;&#39;static str, string: &amp;amp;&#39;static [u8; 12]) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let mut f = try!(File::create(filename));
    try!(f.write_all(string));
    Ok(())
}

fn main() {
    match log_something(&quot;log.txt&quot;, b&quot;ITS ALIVE!!!&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;

&lt;p&gt;
I&#39;ll just do a real quick merge of the above example with this one:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
extern crate chrono;

use std::io::prelude::*;
use std::fs::File;
use std::io;
use chrono::*;

fn log_something(filename: &amp;amp;&#39;static str, string: &amp;amp;&#39;static [u8; 12]) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let mut f = try!(File::create(filename));
    try!(f.write_all(string));
    Ok(())
}

fn main() {
    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    println!(&#39;{}&#39;, local);
    match log_something(&quot;log.txt&quot;, b&quot;ITS ALIVE!!!&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;

&lt;p&gt;
compiling:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ ls
Cargo.lock      Cargo.toml      log.txt         src             target
$ pwd
/Users/joel/Projects/simple-log
$ ls
Cargo.lock      Cargo.toml      log.txt         src             target
$ rm log.txt
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
     Running `target/debug/simple-log`
2015-06-05 17:08:57.814176 -04:00
File created!
$ cat log.txt
ITS ALIVE!!!$
&lt;/pre&gt;

&lt;p&gt;
That all worked! It feels really good to go from struggling with a
language, to being able to put things together with much less
frustration.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-4&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-4&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;4&lt;/span&gt; Building a File Logger&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-4&quot;&gt;
&lt;p&gt;
We&#39;re getting closer to writing a real, bona fide piece of the final
system. It hits me that I might like to write some tests for this
code, but I&#39;ll add those in later.
&lt;/p&gt;


&lt;p&gt;
Here&#39;s what this function should do:
&lt;/p&gt;

&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;Given a file name,
&lt;/li&gt;
&lt;li&gt;Create it first if doesn&#39;t exist, and open the file.
&lt;/li&gt;
&lt;li&gt;Create a time/date string,
&lt;/li&gt;
&lt;li&gt;Write that string to the file, and close the file.
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;


&lt;div id=&quot;outline-container-sec-4-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-4-1&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;4.1&lt;/span&gt; Misunderstanding &lt;code&gt;u8&lt;/code&gt;&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-4-1&quot;&gt;
&lt;p&gt;
My first attempt:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
extern crate chrono;

use std::io::prelude::*;
use std::fs::File;
use std::io;
use chrono::*;

fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;()&amp;gt; {

    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    let time_str = local.format(&quot;%Y&quot;).to_string();
    let mut f = try!(File::create(filename));
    try!(f.write_all(time_str));
    Ok(())
}

fn main() {
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:13:22: 13:30 error: mismatched types:
 expected `&amp;amp;[u8]`,
    found `collections::string::String`
(expected &amp;amp;-ptr,
    found struct `collections::string::String`) [E0308]
src/main.rs:13     try!(f.write_all(time_str));
                                    ^~~~~~~~
&amp;lt;std macros&amp;gt;:1:1: 6:48 note: in expansion of try!
src/main.rs:13:5: 13:33 note: expansion site
error: aborting due to previous error
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
Ugh. So, I know that there are many types of strings in
Rust&lt;sup&gt;&lt;a id=&quot;fnr.1&quot; name=&quot;fnr.1&quot; class=&quot;footref&quot; href=&quot;#fn.1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, and it
looks like I need a different one, here. Thing is, I don&#39;t know how to
do this, so I&#39;ll have to do some searching.
&lt;/p&gt;

&lt;p&gt;
I remember seeing &lt;a href=&quot;http://doc.rust-lang.org/book/strings.html&quot;&gt;a section in the Rust&lt;/a&gt; book specifically about
strings. Looking into it, it says that a can be converted from
&lt;code&gt;String&lt;/code&gt; to &lt;code&gt;&amp;amp;str&lt;/code&gt; with an ampersand (&lt;code&gt;&amp;amp;&lt;/code&gt;). I don&#39;t think this is
quite right, because it looks like it&#39;s expecting a &lt;code&gt;[u8]&lt;/code&gt; and &lt;i&gt;not&lt;/i&gt;
a &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;sup&gt;&lt;a id=&quot;fnr.2&quot; name=&quot;fnr.2&quot; class=&quot;footref&quot; href=&quot;#fn.2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; Lemmie try that:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
extern crate chrono;

use std::io::prelude::*;
use std::fs::File;
use std::io;
use chrono::*;

fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;()&amp;gt; {

    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    let time_str = local.format(&quot;%Y&quot;).to_string();
    let mut f = try!(File::create(filename));
    try!(f.write_all(&amp;amp;time_str));
    Ok(())
}

fn main() {
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:13:22: 13:31 error: mismatched types:
 expected `&amp;amp;[u8]`,
    found `&amp;amp;collections::string::String`
(expected slice,
    found struct `collections::string::String`) [E0308]
src/main.rs:13     try!(f.write_all(&amp;amp;time_str));
                                    ^~~~~~~~~
&amp;lt;std macros&amp;gt;:1:1: 6:48 note: in expansion of try!
src/main.rs:13:5: 13:34 note: expansion site
error: aborting due to previous error
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;


&lt;p&gt;
Well. Apparently, adding the ampersand just converted a &lt;code&gt;String&lt;/code&gt; to an
&lt;code&gt;&amp;amp;String&lt;/code&gt;. That seems to directly contradict what the Rust book is
saying, but I also probably don&#39;t know what is going on.
&lt;/p&gt;

&lt;p&gt;
&amp;#x2026;And I just reached the end of the chapter on strings. Harumph. As
far as I can tell, there isn&#39;t anything in here.
&lt;/p&gt;

&lt;p&gt;
I walked away from this for a while (because, you know, life), and
while I was gone it hit me. All this time, I have been reading &lt;code&gt;u8&lt;/code&gt; as
a short form of &lt;code&gt;UTF-8&lt;/code&gt;, but now that I think about it, it almost
certainly actually means &quot;unsigned 8-bit integer&quot;. And, I remember
seeing an &lt;code&gt;as_bytes&lt;/code&gt; method, so let me try that instead:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
extern crate chrono;

use std::io::prelude::*;
use std::fs::File;
use std::io;
use chrono::*;

fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    let bytes = local.format(&quot;%Y&quot;).to_string().as_bytes();
    let mut f = try!(File::create(filename));
    try!(f.write_all(bytes));
    Ok(())
}

fn main() {
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
main.rs:10:17: 10:47 error: borrowed value does not live long enough
main.rs:10     let bytes = local.format(&quot;%Y&quot;).to_string().as_bytes();
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
main.rs:10:59: 14:2 note: reference must be valid for the block suffix following statement 1 at 10:
58...
main.rs:10     let bytes = local.format(&quot;%Y&quot;).to_string().as_bytes();
main.rs:11     let mut f = try!(File::create(filename));
main.rs:12     try!(f.write_all(bytes));
main.rs:13     Ok(())
main.rs:14 }
main.rs:10:5: 10:59 note: ...but borrowed value is only valid for the statement at 10:4
main.rs:10     let bytes = local.format(&quot;%Y&quot;).to_string().as_bytes();
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
main.rs:10:5: 10:59 help: consider using a `let` binding to increase its lifetime
main.rs:10     let bytes = local.format(&quot;%Y&quot;).to_string().as_bytes();
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
Well, I &lt;i&gt;hope&lt;/i&gt; this is progress. Does this error mean I fixed
something, and there was something else wrong that was obscuring this
problem? Did I introduce a whole new problem?
&lt;/p&gt;

&lt;p&gt;
The strange thing about this error message is that it seems to be
talking about error messages on the same line. I don&#39;t really
understand most of it, but I&#39;m thinking it is saying that I need to
add a let in the middle of the sequence of method calls. Lets try:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    let formatted = local.format(&quot;%Y&quot;).to_string();
    let bytes = formatted.as_bytes();
    let mut f = try!(File::create(filename));
    try!(f.write_all(bytes));
    Ok(())
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
     Running `target/debug/simple-log`
File created!
$ cat log.txt
2015$
&lt;/pre&gt;

&lt;p&gt;
Great! All the pieces are here. Before I move on, I want to reflect
that I find this a little disappointing. It seems like Rust should be
able to infer the correct behavior in the previous snippet without my
guidance.
&lt;/p&gt;

&lt;p&gt;
Testing the script:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ ls
Cargo.lock      Cargo.toml      log.txt         src             target
$ rm log.txt
$ cargo run
     Running `target/debug/simple-log`
File created!
$ cat log.txt
2015$ cargo run
     Running `target/debug/simple-log`
File created!
$ cat log.txt
2015$
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-4-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-4-2&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;4.2&lt;/span&gt; Filling in Missing Pieces&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-4-2&quot;&gt;
&lt;p&gt;
A few problems:
&lt;/p&gt;

&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;No newline. This is really gross.
&lt;/li&gt;

&lt;li&gt;The format needs some work.
&lt;/li&gt;

&lt;li&gt;It appears that the old value is being erased by the new value.
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
Let&#39;s verify #3 by fixing the format. If the time changes between
runs, then we will know that&#39;s what is happening.
&lt;/p&gt;

&lt;p&gt;
The &lt;code&gt;format&lt;/code&gt; method of &lt;code&gt;DateTime&lt;/code&gt; uses the standard strftime
formatting conventions. Ideally, I would like times to be something
like:
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
Sat, Jun 6 2015 05:32:00 PM
Sun, Jun 7 2015 08:35:00 AM
&lt;/pre&gt;
&lt;p&gt;
&amp;#x2026;etc. This should be readable enough for me to use. After reading
&lt;a href=&quot;https://lifthrasiir.github.io/rust-chrono/chrono/format/strftime/index.html&quot;&gt;the documentation&lt;/a&gt; for a while, I&#39;ve come up with this:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
extern crate chrono;

use std::io::prelude::*;
use std::fs::File;
use std::io;
use chrono::*;

fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    let formatted = local.format(&quot;%a, %b %d %Y %I:%M:%S %p\n&quot;).to_string();
    let bytes = formatted.as_bytes();
    let mut f = try!(File::create(filename));
    try!(f.write_all(bytes));
    Ok(())
}

fn main() {
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;

&lt;p&gt;
Testing it:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ rm log.txt
$ cargo run
     Running `target/debug/simple-log`
File created!
$ cat log.txt
Sun, Jun 07 2015 06:37:21 PM
$ sleep 5; cargo run
     Running `target/debug/simple-log`
File created!
$ cat log.txt
Sun, Jun 07 2015 06:37:41 PM
&lt;/pre&gt;

&lt;p&gt;
So, clearly the program is overwriting the log entries, which tbqh is
what I expect, as I remember the documentation for &lt;code&gt;File::create&lt;/code&gt;
specifying that this is what would happen. So, I need to look at the
documentation for manipulating files again.
&lt;/p&gt;

&lt;p&gt;
I did some searching around, and basically finding the answer to this
isn&#39;t trivial. After a while I found the documentation for
&lt;a href=&quot;https://doc.rust-lang.org/std/path/struct.Path.html&quot;&gt;std::path::Path&lt;/a&gt;, which has an &lt;code&gt;exists&lt;/code&gt; method.
&lt;/p&gt;

&lt;p&gt;
At this point, the interactions between types in my application is
becoming increasingly hard to manage. I feel nervous, so I will commit
before continuing.
&lt;/p&gt;

&lt;p&gt;
I want to pull the time entry string generation out of the &lt;code&gt;log_time&lt;/code&gt;
function because it seems like the entry formatting/creation is
distinct from the file manipulation code. So, trying this:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
extern crate chrono;

use std::io::prelude::*;
use std::fs::File;
use std::io;
use chrono::*;


fn log_time_entry() -&amp;gt; String {
    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    let formatted = local.format(&quot;%a, %b %d %Y %I:%M:%S %p\n&quot;).to_string();
    formatted
}

fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let bytes = log_time_entry().as_bytes();
    let mut f = try!(File::create(filename));
    try!(f.write_all(bytes));
    Ok(())
}

fn main() {
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:16:17: 16:33 error: borrowed value does not live long enough
src/main.rs:16     let bytes = log_time_entry().as_bytes();
                               ^~~~~~~~~~~~~~~~
src/main.rs:16:45: 20:2 note: reference must be valid for the block suffix following statement 0 at
 16:44...
src/main.rs:16     let bytes = log_time_entry().as_bytes();
src/main.rs:17     let mut f = try!(File::create(filename));
src/main.rs:18     try!(f.write_all(bytes));
src/main.rs:19     Ok(())
src/main.rs:20 }
src/main.rs:16:5: 16:45 note: ...but borrowed value is only valid for the statement at 16:4
src/main.rs:16     let bytes = log_time_entry().as_bytes();
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
src/main.rs:16:5: 16:45 help: consider using a `let` binding to increase its lifetime
src/main.rs:16     let bytes = log_time_entry().as_bytes();
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
So, this looks just like the problem I had earlier. Does
borrowing/ownership require that a function have an explicit reference
to resources? That seems a little strange. I will try to fix it again:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
extern crate chrono;

use std::io::prelude::*;
use std::fs::File;
use std::io;
use chrono::*;

fn formatted_time_entry() -&amp;gt; String {
    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    let formatted = local.format(&quot;%a, %b %d %Y %I:%M:%S %p\n&quot;).to_string();
    formatted
}

fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let entry = formatted_time_entry();
    let bytes = entry.as_bytes();

    let mut f = try!(File::create(filename));
    try!(f.write_all(bytes));
    Ok(())
}

fn main() {
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
     Running `target/debug/simple-log`
File created!
&lt;/pre&gt;

&lt;p&gt;
So, adding an explicit reference seems to be the
solution. Whatever. It is an easy rule to learn and follow.
&lt;/p&gt;

&lt;p&gt;
Next I want to extract the file manipulation code to its own function:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
extern crate chrono;

use std::io::prelude::*;
use std::fs::File;
use std::io;
use chrono::*;

fn formatted_time_entry() -&amp;gt; String {
    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    let formatted = local.format(&quot;%a, %b %d %Y %I:%M:%S %p\n&quot;).to_string();
    formatted
}

fn record_entry_in_log(filename: &amp;amp;str, bytes: &amp;amp;[u8]) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let mut f = try!(File::create(filename));
    try!(f.write_all(bytes));
    Ok(())
}

fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let entry = formatted_time_entry();
    let bytes = entry.as_bytes();

    try!(record_entry_in_log(filename, &amp;amp;bytes));
    Ok(())
}

fn main() {
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;

&lt;p&gt;
And this works. I made some initial errors, but they were quickly
corrected and was all stuff that has been covered here before.
&lt;/p&gt;

&lt;p&gt;
Looking into the documentation for
&lt;a href=&quot;https://doc.rust-lang.org/std/fs/struct.File.html&quot;&gt;std::fs::File&lt;/a&gt;, I notice a reference to
&lt;a href=&quot;https://doc.rust-lang.org/std/fs/struct.OpenOptions.html&quot;&gt;std::fs::OpenOptions&lt;/a&gt;, which is &lt;i&gt;exactly&lt;/i&gt; what I have been looking
for. It would definitely be better than using &lt;code&gt;std::path&lt;/code&gt;.
&lt;/p&gt;


&lt;p&gt;
My first attempt:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
extern crate chrono;

use std::io::prelude::*;
use std::fs::{File,OpenOptions};
use std::io;
use chrono::{DateTime,Local};


fn formatted_time_entry() -&amp;gt; String {
    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    let formatted = local.format(&quot;%a, %b %d %Y %I:%M:%S %p\n&quot;).to_string();
    formatted
}

fn record_entry_in_log(filename: &amp;amp;str, bytes: &amp;amp;[u8]) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let mut file = try!(OpenOptions::new().
                        append(true).
                        create(true).
                        open(filename));
    try!(file.write_all(bytes));
    Ok(())
}

fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let entry = formatted_time_entry();
    let bytes = entry.as_bytes();

    try!(record_entry_in_log(filename, &amp;amp;bytes));
    Ok(())
}

fn main() {
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:4:15: 4:19 warning: unused import, #[warn(unused_imports)] on by default
src/main.rs:4 use std::fs::{File,OpenOptions};
                            ^~~~
     Running `target/debug/simple-log`
Error: could not create file.
&lt;/pre&gt;

&lt;p&gt;
Interesting. I see that it &lt;i&gt;is&lt;/i&gt; actually creating the file, after
which I notice this is the message I&#39;ve hard-coded into &lt;code&gt;main&lt;/code&gt;. Ugh; I
think this will work:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
extern crate chrono;

use std::io::prelude::*;
use std::fs::{File,OpenOptions};
use std::io;
use chrono::{DateTime,Local};


fn formatted_time_entry() -&amp;gt; String {
    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    let formatted = local.format(&quot;%a, %b %d %Y %I:%M:%S %p\n&quot;).to_string();
    formatted
}

fn record_entry_in_log(filename: &amp;amp;str, bytes: &amp;amp;[u8]) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let mut file = try!(OpenOptions::new().
                        append(true).
                        create(true).
                        open(filename));
    try!(file.write_all(bytes));
    Ok(())
}

fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let entry = formatted_time_entry();
    let bytes = entry.as_bytes();

    try!(record_entry_in_log(filename, &amp;amp;bytes));
    Ok(())
}

fn main() {
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(e) =&amp;gt; println!(&quot;Error: {}&quot;, e)
    }
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:4:15: 4:19 warning: unused import, #[warn(unused_imports)] on by default
src/main.rs:4 use std::fs::{File,OpenOptions};
                            ^~~~
     Running `target/debug/simple-log`
Error: Bad file descriptor (os error 9)
&lt;/pre&gt;

&lt;p&gt;
Weird. Searching for this &quot;bad file descriptor&quot; error message seems to
indicate that this happens when a file descriptor is used has been
closed. what happens if I comment out the &lt;code&gt;file.write_all&lt;/code&gt; call?
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ rm log.txt
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:3:5: 3:25 warning: unused import, #[warn(unused_imports)] on by default
src/main.rs:3 use std::io::prelude::*;
                  ^~~~~~~~~~~~~~~~~~~~
src/main.rs:4:15: 4:19 warning: unused import, #[warn(unused_imports)] on by default
src/main.rs:4 use std::fs::{File,OpenOptions};
                            ^~~~
src/main.rs:15:40: 15:45 warning: unused variable: `bytes`, #[warn(unused_variables)] on by default
src/main.rs:15 fn record_entry_in_log(filename: &amp;amp;str, bytes: &amp;amp;[u8]) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
                                                      ^~~~~
src/main.rs:16:9: 16:17 warning: unused variable: `file`, #[warn(unused_variables)] on by default
src/main.rs:16     let mut file = try!(OpenOptions::new().
                       ^~~~~~~~
src/main.rs:16:9: 16:17 warning: variable does not need to be mutable, #[warn(unused_mut)] on by de
fault
src/main.rs:16     let mut file = try!(OpenOptions::new().
                       ^~~~~~~~
     Running `target/debug/simple-log`
File created!
$ ls
Cargo.lock      Cargo.toml      log.txt         src             target
&lt;/pre&gt;

&lt;p&gt;
Unsurprisingly, there are a bunch unused messages, but aside from
that the file is indeed created.
&lt;/p&gt;

&lt;p&gt;
It seems a little silly, but I tried adding &lt;code&gt;.write(true)&lt;/code&gt; to the
chain of functions, and it worked. It seems like &lt;code&gt;.append(true)&lt;/code&gt;
should imply &lt;code&gt;.write(true)&lt;/code&gt;, but I guess it doesn&#39;t.
&lt;/p&gt;

&lt;p&gt;
And with that, its working! The final version:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
extern crate chrono;

use std::io::prelude::*;
use std::fs::{File,OpenOptions};
use std::io;
use chrono::{DateTime,Local};


fn formatted_time_entry() -&amp;gt; String {
    let local: DateTime&amp;lt;Local&amp;gt; = Local::now();
    let formatted = local.format(&quot;%a, %b %d %Y %I:%M:%S %p\n&quot;).to_string();
    formatted
}

fn record_entry_in_log(filename: &amp;amp;str, bytes: &amp;amp;[u8]) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let mut file = try!(OpenOptions::new().
                        append(true).
                        write(true).
                        create(true).
                        open(filename));
    try!(file.write_all(bytes));
    Ok(())
}

fn log_time(filename: &amp;amp;&#39;static str) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let entry = formatted_time_entry();
    let bytes = entry.as_bytes();

    try!(record_entry_in_log(filename, &amp;amp;bytes));
    Ok(())
}

fn main() {
    match log_time(&quot;log.txt&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(e) =&amp;gt; println!(&quot;Error: {}&quot;, e)
    }
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ ls
Cargo.lock      Cargo.toml      src             target
$ cargo run
     Running `target/debug/simple-log`
File created!
$ cargo run
     Running `target/debug/simple-log`
File created!
$ cat log.txt
Sun, Jun 07 2015 10:40:01 PM
Sun, Jun 07 2015 10:40:05 PM
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-5&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-5&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;5&lt;/span&gt; Conclusion &amp;amp; Next Steps&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-5&quot;&gt;
&lt;p&gt;
Rust is getting easier for me. I now have some reasonably factored
code to work with, and I feel fairly confident about starting on the
next part of the application.
&lt;/p&gt;

&lt;p&gt;
When I was first planning this series, I expected the next task to be
integrating the logging code with the &lt;code&gt;nickel.rs&lt;/code&gt; code, but at this
point I think it is going to be pretty simple. I suspect that the next
difficult part will be handling &lt;a href=&quot;http://doc.rust-lang.org/getopts/getopts/index.html&quot;&gt;option parsing&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
&amp;#x2014;
&lt;/p&gt;

&lt;p&gt;
Series: A Simple Web App in Rust
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-1/&quot;&gt;Part 1&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-2a/&quot;&gt;Part 2a&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-2b/&quot;&gt;Part 2b&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-3/&quot;&gt;Part 3&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-4-cli-option-parsing/&quot;&gt;Part 4&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-conclusion/&quot;&gt;Conclusion&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;footnotes&quot;&gt;
&lt;h2 class=&quot;footnotes&quot;&gt;Footnotes: &lt;/h2&gt;
&lt;div id=&quot;text-footnotes&quot;&gt;

&lt;div class=&quot;footdef&quot;&gt;&lt;sup&gt;&lt;a id=&quot;fn.1&quot; name=&quot;fn.1&quot; class=&quot;footnum&quot; href=&quot;#fnr.1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;p class=&quot;footpara&quot;&gt;
Having many types of strings is a completely reasonable
thing. Strings are a
complicated subject and hard to get right.
Unfortunately, at first glance strings seem very simple, and this kind
of things seems like needless complication
&lt;/p&gt;&lt;/div&gt;

&lt;div class=&quot;footdef&quot;&gt;&lt;sup&gt;&lt;a id=&quot;fn.2&quot; name=&quot;fn.2&quot; class=&quot;footnum&quot; href=&quot;#fnr.2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; &lt;p class=&quot;footpara&quot;&gt;
I basically have no idea what I&#39;m talking about
here. These are just things I&#39;ve seen that I&#39;m to make sense of.
&lt;/p&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;</description>
        <pubDate>Sun, 07 Jun 2015 00:00:00 -0400</pubDate>
        <link>http://joelmccracken.github.io//entries/a-simple-web-app-in-rust-pt-2b/</link>
        <guid isPermaLink="true">http://joelmccracken.github.io//entries/a-simple-web-app-in-rust-pt-2b/</guid>
      </item>
    
      <item>
        <title>A Simple Web App in Rust, Part 2a</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. Context&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-2&quot;&gt;2. Starting Out&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-3&quot;&gt;3. Remembering &quot;hello world&quot;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-4&quot;&gt;4. A Naive Approach&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-5&quot;&gt;5. Debugging by Expanding Macros&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-6&quot;&gt;6. Fighting with Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-7&quot;&gt;7. Writing to a file&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-8&quot;&gt;8. Updates&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; Context&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
If you haven&#39;t checked out part 1 of this series, I would start
&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-1&quot;&gt;there&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
In the first part, we successfully set up the Rust project and built a
simple &quot;hello world&quot; web app.
&lt;/p&gt;

&lt;p&gt;
Originally, in this part, I wanted to write a program that writes
dates to the filesystem. However, I ended up fighting with the type
checker so much that this post ended up mostly being about that.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;2&lt;/span&gt; Starting Out&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;
&lt;p&gt;
The last time wasn&#39;t too bad. When I did some of this earlier, I
remember this being the hardest part.
&lt;/p&gt;

&lt;p&gt;
Let&#39;s start by moving the existing &lt;code&gt;main.rs&lt;/code&gt; out of the way so that we
can work with a fresh file.
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ pwd
/Users/joel/Projects/simple-log
$ cd src/
$ ls
main.rs
$ mv main.rs web_main.rs
$ touch main.rs
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;3&lt;/span&gt; Remembering &quot;hello world&quot;&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;
&lt;p&gt;
Can I write a hello world without needing to look?
&lt;/p&gt;

&lt;p&gt;
Let me try:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
fn main() {
    println!(&quot;Hello, world&quot;);
}
&lt;/pre&gt;

&lt;p&gt;
Then:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
     Running `target/debug/simple-log`
Hello, world
&lt;/pre&gt;

&lt;p&gt;
So, I guess I remember it OK. I was a little unsure about needing to
import something for &lt;code&gt;println!&lt;/code&gt;, but it must be unnecessary.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-4&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-4&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;4&lt;/span&gt; A Naive Approach&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-4&quot;&gt;
&lt;p&gt;
Ok, moving on. Searching the Internet for &quot;rust create a file&quot; leads
me to this page on &lt;code&gt;std::fs::File&lt;/code&gt;:
&lt;a href=&quot;https://doc.rust-lang.org/std/fs/struct.File.html&quot;&gt;https://doc.rust-lang.org/std/fs/struct.File.html&lt;/a&gt;. Let&#39;s try a piece
from one example:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
use std::fs::File;

fn main() {
    let mut f = try!(File::create(&quot;foo.txt&quot;));
}
&lt;/pre&gt;

&lt;p&gt;
Building:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
&amp;lt;std macros&amp;gt;:5:8: 6:42 error: mismatched types:
 expected `()`,
    found `core::result::Result&amp;lt;_, _&amp;gt;`
(expected (),
    found enum `core::result::Result`) [E0308]
&amp;lt;std macros&amp;gt;:5 return $ crate:: result:: Result:: Err (
&amp;lt;std macros&amp;gt;:6 $ crate:: convert:: From:: from ( err ) ) } } )
&amp;lt;std macros&amp;gt;:1:1: 6:48 note: in expansion of try!
src/main.rs:5:17: 5:46 note: expansion site
error: aborting due to previous error
Could not compile `simple-log`.
&lt;/pre&gt;

&lt;p&gt;
When I wrote the first version of this, this error took
a &lt;i&gt;really&lt;/i&gt; longtime to figure out. I don&#39;t get on IRC very often
anymore, so figuring things out like this can be pretty
rough. Figuring it out left a big impression on me, so I know the
answer right away.
&lt;/p&gt;

&lt;p&gt;
The problem with the above code is that &lt;code&gt;try!&lt;/code&gt; expands to something
that returns early with an &lt;code&gt;Err&lt;/code&gt; type in case of an error. Since
&lt;code&gt;main&lt;/code&gt; returns Unit (&quot;&lt;code&gt;()&lt;/code&gt;&quot;)&lt;sup&gt;&lt;a id=&quot;fnr.1&quot; name=&quot;fnr.1&quot; class=&quot;footref&quot; href=&quot;#fn.1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, this causes a type error.
&lt;/p&gt;

&lt;p&gt;
I think three things make this complicated:
&lt;/p&gt;

&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;At this point, I&#39;m not really sure how to read the error
message. What does &#39;expected&#39; and &#39;found&#39; refer to? Since I know
the answer, I can see that &#39;expected&#39; refers to the return value of
&lt;code&gt;main&lt;/code&gt;, but I could easily see &#39;expected&#39;/&#39;found&#39; going either
way.
&lt;/li&gt;

&lt;li&gt;For me, reading &lt;a href=&quot;https://doc.rust-lang.org/std/macro.try!.html&quot;&gt;the documentation&lt;/a&gt; for &lt;code&gt;try!&lt;/code&gt; does not immediately
indicate to me how &lt;code&gt;try!&lt;/code&gt; impacts the return value of the function it
is called from. Of course, I should have noticed the &lt;code&gt;return&lt;/code&gt; in
the macro definition. At any rate, I didn&#39;t figure the problem out
until I found a remark in &lt;a href=&quot;http://doc.rust-lang.org/stable/book/&quot;&gt;the Rust book&lt;/a&gt; about how &lt;code&gt;try!&lt;/code&gt; can&#39;t be
called from &lt;code&gt;main&lt;/code&gt; because of this exact problem.
&lt;/li&gt;

&lt;li&gt;The error actually occurs inside a macro. It didn&#39;t hit me at the
time, but the rust compiler can output the code after macros have been
expanded. That makes this kind of thing much easier to debug.
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
In number 3, expanding macros is alluded to. Viewing expanded macro is
such a useful way to debug these kinds of issues that its worth
discussing in more depth.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-5&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-5&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;5&lt;/span&gt; Debugging by Expanding Macros&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-5&quot;&gt;
&lt;p&gt;
First off, I figured this out by searching for &quot;rust expand
macros&quot;. Given this code:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
use std::fs::File;

fn main() {
    let mut f = try!(File::create(&quot;foo.txt&quot;));
}
&lt;/pre&gt;

&lt;p&gt;
&amp;#x2026; we can run the compiler to show us the expanded macro output this way:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ rustc src/main.rs --pretty=expanded -Z unstable-options
#![feature(no_std)]
#![no_std]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std as std;
use std::fs::File;

fn main() {
    let mut f =
        match File::create(&quot;foo.txt&quot;) {
            ::std::result::Result::Ok(val) =&amp;gt; val,
            ::std::result::Result::Err(err) =&amp;gt; {
                return ::std::result::Result::Err(::std::convert::From::from(err))
            }
        };
}
&lt;/pre&gt;

&lt;p&gt;
This is &lt;i&gt;way&lt;/i&gt; easier to debug. Macros are a very powerful tool, but
like any tool you need to know when and how to use them.
&lt;/p&gt;

&lt;p&gt;
So, see that &lt;code&gt;return&lt;/code&gt; statement in the above output? That&#39;s the
problem. Its trying to return an &lt;code&gt;Err&lt;/code&gt; result from &lt;code&gt;main&lt;/code&gt;, which again
has the return type Unit.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-6&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-6&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;6&lt;/span&gt; Fighting with Types&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-6&quot;&gt;
&lt;p&gt;
I need to know how to resolve this type problem. I&#39;m going to start by imitating the
&lt;code&gt;try!&lt;/code&gt; macro, but this time only returning Unit:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
use std::fs::File;

fn main() {
    match File::create(&quot;foo.txt&quot;) {
        Ok(val) =&amp;gt; val,
        Err(err) =&amp;gt; ()
    }
}
&lt;/pre&gt;

&lt;p&gt;
Running:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:5:5: 8:6 error: match arms have incompatible types:
 expected `std::fs::File`,
    found `()`
(expected struct `std::fs::File`,
    found ()) [E0308]
src/main.rs:5     match File::create(&quot;foo.txt&quot;) {
src/main.rs:6         Ok(val) =&amp;gt; val,
src/main.rs:7         Err(err) =&amp;gt; ()
src/main.rs:8     }
src/main.rs:7:21: 7:23 note: match arm with an incompatible type
src/main.rs:7         Err(err) =&amp;gt; ()
                                  ^~
error: aborting due to previous error
Could not compile `simple-log`.
&lt;/pre&gt;

&lt;p&gt;
Huh. So, I&#39;m not really sure how to say &quot;don&#39;t do anything, here&quot;. I
guess the type &#39;val&#39; must be &#39;std::fs::File&#39;, and so its assuming that &lt;i&gt;any&lt;/i&gt;
match return value must be that. Can I make the &lt;code&gt;Ok&lt;/code&gt; branch not return
anything, either?
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
use std::fs::File;

fn main() {
    match File::create(&quot;foo.txt&quot;) {
        Ok(val) =&amp;gt; (),
        Err(err) =&amp;gt; ()
    }
}
&lt;/pre&gt;

&lt;p&gt;
Running:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:6:12: 6:15 warning: unused variable: `val`, #[warn(unused_variables)] on by default
src/main.rs:6         Ok(val) =&amp;gt; (),
                         ^~~
src/main.rs:7:13: 7:16 warning: unused variable: `err`, #[warn(unused_variables)] on by default
src/main.rs:7         Err(err) =&amp;gt; ()
                          ^~~
     Running `target/debug/simple-log`
$ ls
Cargo.lock      Cargo.toml      foo.txt         src             target
&lt;/pre&gt;

&lt;p&gt;
It created &lt;code&gt;foo.txt&lt;/code&gt;! Of course, the code could be cleaner, but thats
fine for now. Let me try something else:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
use std::fs::File;

fn main() {
    File::create(&quot;foo.txt&quot;)
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ rm foo.txt
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:5:5: 5:28 error: mismatched types:
 expected `()`,
    found `core::result::Result&amp;lt;std::fs::File, std::io::error::Error&amp;gt;`
(expected (),
    found enum `core::result::Result`) [E0308]
src/main.rs:5     File::create(&quot;foo.txt&quot;)
                  ^~~~~~~~~~~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
I&#39;ve seen this before. This must mean &lt;code&gt;main&lt;/code&gt; is returning the result of
&lt;code&gt;File::create&lt;/code&gt;. I was thinking it would return nothing, but I guess I
didn&#39;t really think that through. What if I add a semicolon?
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
use std::fs::File;

fn main() {
    File::create(&quot;foo.txt&quot;);
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ rm foo.txt
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:5:5: 5:29 warning: unused result which must be used, #[warn(unused_must_use)] on by def
ault
src/main.rs:5     File::create(&quot;foo.txt&quot;);
                  ^~~~~~~~~~~~~~~~~~~~~~~~
     Running `target/debug/simple-log`
$ ls
Cargo.lock      Cargo.toml      foo.txt         src             target
&lt;/pre&gt;

&lt;p&gt;
So, we now get an &quot;unused result&quot; warning, although it still runs and creates the
file. Let&#39;s go back and try doing something that handles the results:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
use std::fs::File;

fn main() {
    match File::create(&quot;foo.txt&quot;) {
        Ok(val) =&amp;gt; println!(&quot;File created!&quot;),
        Err(err) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ rm foo.txt
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:6:12: 6:15 warning: unused variable: `val`, #[warn(unused_variables)] on by default
src/main.rs:6         Ok(val) =&amp;gt; println!(&quot;File created!&quot;),
                         ^~~
src/main.rs:7:13: 7:16 warning: unused variable: `err`, #[warn(unused_variables)] on by default
src/main.rs:7         Err(err) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
                          ^~~
     Running `target/debug/simple-log`
File created!
&lt;/pre&gt;

&lt;p&gt;
Now there are unused variables. My hunch is that either ellipses
or removing the variable name will fix this:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
use std::fs::File;

fn main() {
    match File::create(&quot;foo.txt&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
     Running `target/debug/simple-log`
File created!
&lt;/pre&gt;

&lt;p&gt;
So, ellipses worked. What happens when I instead remove the ellipses?
&lt;/p&gt;


&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:6:12: 6:13 error: nullary enum variants are written with no trailing `( )`
src/main.rs:6         Ok() =&amp;gt; println!(&quot;File created!&quot;),
                         ^
src/main.rs:7:13: 7:14 error: nullary enum variants are written with no trailing `( )`
src/main.rs:7         Err() =&amp;gt; println!(&quot;Error: could not create file.&quot;)
                          ^
error: aborting due to 2 previous errors
Could not compile `simple-log`.
&lt;/pre&gt;

&lt;p&gt;
It didn&#39;t like that. I&#39;m guessing that &quot;nullary&quot; means
&quot;zero-arity&quot;, and it needs those removed. If I remove the parentheses totally:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:6:9: 6:11 error: this pattern has 0 fields, but the corresponding variant has 1 field [
E0023]
src/main.rs:6         Ok =&amp;gt; println!(&quot;File created!&quot;),
                      ^~
src/main.rs:7:9: 7:12 error: this pattern has 0 fields, but the corresponding variant has 1 field [
E0023]
src/main.rs:7         Err =&amp;gt; println!(&quot;Error: could not create file.&quot;)
                      ^~~
error: aborting due to 2 previous errors
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
This makes sense, and is basically what I expected. My mental
model is starting to form!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-7&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-7&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;7&lt;/span&gt; Writing to a file&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-7&quot;&gt;
&lt;p&gt;
Let&#39;s try something a little harder. How about this:
&lt;/p&gt;

&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;Try to create the log file. If it exists, great; if not, boo.
&lt;/li&gt;

&lt;li&gt;Try to write a string to the log file.
&lt;/li&gt;

&lt;li&gt;Clean everything up.
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
This first example doesn&#39;t even attempt half of that, but we&#39;ll go
with it:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
use std::fs::File;

fn log_something(filename, string) {
    let mut f = try!(File::create(filename));
    try!(f.write_all(string));
}

fn main() {
    match log_something(&quot;log.txt&quot;, &quot;ITS ALIVE!!!&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:3:26: 3:27 error: expected one of `:` or `@`, found `,`
src/main.rs:3 fn log_something(filename, string) {
                                       ^
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
$
&lt;/pre&gt;

&lt;p&gt;
So I guess function arguments need must have type annotations:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
use std::fs::File;

fn log_something(filename: &amp;amp;&#39;static str, string: &amp;amp;&#39;static str) {
    let mut f = try!(File::create(filename));
    try!(f.write_all(string));
}

fn main() {
    match log_something(&quot;log.txt&quot;, &quot;ITS ALIVE!!!&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
&amp;lt;std macros&amp;gt;:5:8: 6:42 error: mismatched types:
 expected `()`,
    found `core::result::Result&amp;lt;_, _&amp;gt;`
(expected (),
    found enum `core::result::Result`) [E0308]
&amp;lt;std macros&amp;gt;:5 return $ crate:: result:: Result:: Err (
&amp;lt;std macros&amp;gt;:6 $ crate:: convert:: From:: from ( err ) ) } } )
&amp;lt;std macros&amp;gt;:1:1: 6:48 note: in expansion of try!
src/main.rs:4:17: 4:45 note: expansion site
src/main.rs:5:12: 5:29 error: type `std::fs::File` does not implement any method in scope named `wr
ite_all`
src/main.rs:5     try!(f.write_all(string));
                         ^~~~~~~~~~~~~~~~~
&amp;lt;std macros&amp;gt;:1:1: 6:48 note: in expansion of try!
src/main.rs:5:5: 5:31 note: expansion site
src/main.rs:5:12: 5:29 help: methods from traits can only be called if the trait is in scope; the f
ollowing trait is implemented but not in scope, perhaps add a `use` for it:
src/main.rs:5:12: 5:29 help: candidate #1: use `std::io::Write`
&amp;lt;std macros&amp;gt;:5:8: 6:42 error: mismatched types:
 expected `()`,
    found `core::result::Result&amp;lt;_, _&amp;gt;`
(expected (),
    found enum `core::result::Result`) [E0308]
&amp;lt;std macros&amp;gt;:5 return $ crate:: result:: Result:: Err (
&amp;lt;std macros&amp;gt;:6 $ crate:: convert:: From:: from ( err ) ) } } )
&amp;lt;std macros&amp;gt;:1:1: 6:48 note: in expansion of try!
src/main.rs:5:5: 5:31 note: expansion site
src/main.rs:10:9: 10:15 error: mismatched types:
 expected `()`,
    found `core::result::Result&amp;lt;_, _&amp;gt;`
(expected (),
    found enum `core::result::Result`) [E0308]
src/main.rs:10         Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
                       ^~~~~~
src/main.rs:11:9: 11:16 error: mismatched types:
 expected `()`,
    found `core::result::Result&amp;lt;_, _&amp;gt;`
(expected (),
    found enum `core::result::Result`) [E0308]
src/main.rs:11         Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
                       ^~~~~~~
error: aborting due to 5 previous errors
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
That&#39;s a lot of errors. Looking at the first error, I&#39;m guessing
that &lt;code&gt;log_something&lt;/code&gt; needs to have a return value specified. I&#39;ve
tried a few things, but right now I&#39;m stuck. To the search engines!
&lt;/p&gt;

&lt;p&gt;
A few minutes have passed, and I finally have &lt;i&gt;an&lt;/i&gt; answer. I did
&lt;a href=&quot;https://github.com/search?p=15&amp;q=Result+language:rust&amp;ref=simplesearch&amp;type=Code&amp;utf8=%E2%9C%93&quot;&gt;some searching on GitHub&lt;/a&gt;,
but it wasn&#39;t fruitful. I tried about 50 different things, but got
this to work:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
use std::io::prelude::*;
use std::fs::File;

fn log_something(filename: &amp;amp;&#39;static str, string: &amp;amp;&#39;static str) -&amp;gt; Result&amp;lt;File,std::io::error::Error&amp;gt; {
    let mut f = try!(File::create(filename));
    try!(f.write_all(string));
}

fn main() {
    match log_something(&quot;log.txt&quot;, &quot;ITS ALIVE!!!&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;

&lt;p&gt;
I&#39;m not really sure &lt;i&gt;why&lt;/i&gt; it works. If I understand correctly, the
return value is of &lt;code&gt;Result&lt;/code&gt; type that&#39;s parameterized with the types
&lt;code&gt;File&lt;/code&gt; and &lt;code&gt;std::io::error::Error&lt;/code&gt;. What does this mean, exactly? It
seems strange to me that of the two types, one type is the
actual result (a file), yet the second is an &lt;code&gt;Error&lt;/code&gt; type. Why? I&#39;m
thinking that once I fix the remaining error(s), this will need fixing
again.
&lt;/p&gt;

&lt;p&gt;
So, now when I try to run it, I get:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:8:22: 8:28 error: mismatched types:
 expected `&amp;amp;[u8]`,
    found `&amp;amp;&#39;static str`
(expected slice,
    found str) [E0308]
src/main.rs:8     try!(f.write_all(string));
                                   ^~~~~~
&amp;lt;std macros&amp;gt;:1:1: 6:48 note: in expansion of try!
src/main.rs:8:5: 8:31 note: expansion site
error: aborting due to previous error
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;

&lt;p&gt;
Ok, so I saw in the example that they prefixed the string with a &lt;code&gt;b&lt;/code&gt;,
which I neglected to do just to see what would happen. Fixing the
parameters:
&lt;/p&gt;


&lt;pre class=&quot;example&quot;&gt;
use std::io::prelude::*;
use std::fs::File;

fn log_something(filename: &amp;amp;&#39;static str, string: &amp;amp;&#39;static [u8; 12]) -&amp;gt; Result&amp;lt;File,std::io::error::Error&amp;gt; {
    let mut f = try!(File::create(filename));
    try!(f.write_all(string));
}

fn main() {
    match log_something(&quot;log.txt&quot;, &quot;ITS ALIVE!!!&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;

&lt;p&gt;
=&amp;gt;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:4:85: 4:106 error: struct `Error` is private
src/main.rs:4 fn log_something(filename: &amp;amp;&#39;static str, string: &amp;amp;&#39;static [u8; 12]) -&amp;gt; Result&amp;lt;File, std::io::error::Error&amp;gt; {
                                                                                                  ^~~~~~~~~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `simple-log`.
&lt;/pre&gt;

&lt;p&gt;
Ugh &amp;#x2013; I knew this was going to be a problem. Time to do some
searching and reading.
&lt;/p&gt;

&lt;p&gt;
The Rust book has &lt;a href=&quot;https://doc.rust-lang.org/book/error-handling.html&quot;&gt;a section&lt;/a&gt; on &lt;code&gt;Result&lt;/code&gt;. Hmm. It seems like what I&#39;m
doing may not be idiomatic? I&#39;d say that it seems like the &quot;best&quot; way
to handle what is going on, but I &lt;i&gt;am&lt;/i&gt; confused. I&#39;ve seen this
&lt;code&gt;unwrap&lt;/code&gt; thing a few times, and it seems like it could be what I
want. If I try unwrap, things might be different:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
fn log_something(filename: &amp;amp;&#39;static str, string: &amp;amp;&#39;static [u8; 12]) {
    let mut f = File::create(filename).unwrap();
    f.write_all(string);
}

fn main() {
    log_something(&quot;log.txt&quot;, b&quot;ITS ALIVE!!!&quot;)
}
&lt;/pre&gt;
&lt;p&gt;
=&amp;gt;
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:6:5: 6:25 warning: unused result which must be used, #[warn(unused_must_use)] on by def
ault
src/main.rs:6     f.write_all(string);
                  ^~~~~~~~~~~~~~~~~~~~
     Running `target/debug/simple-log`
$ ls
Cargo.lock      Cargo.toml      foo.txt         log.txt         src             target
$ cat log.txt
ITS ALIVE!!!
&lt;/pre&gt;

&lt;p&gt;
So, that worked, although there is a warning. I think this is not &quot;the
Rust way&quot;, since its failing early/throwing errors away.
&lt;/p&gt;

&lt;p&gt;
The real problem with &lt;code&gt;try!&lt;/code&gt; and returning a &lt;code&gt;Result&lt;/code&gt; is that there&#39;s
this weirdness dealing with this line in the &lt;code&gt;try!&lt;/code&gt; macro:
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
return $crate::result::Result::Err($crate::convert::From::from(err))
&lt;/pre&gt;
&lt;p&gt;
This means that whatever I pass in has to have a &lt;code&gt;From::from&lt;/code&gt; trait
implemented on an enum, but I really have no idea how traits or enums
work, and I think the whole thing is overkill anyway for what I&#39;m
trying to do.
&lt;/p&gt;

&lt;p&gt;
I&#39;ve gone to the documentation for &lt;code&gt;Result&lt;/code&gt;, and it looks like I may
be going in the wrong direction:
&lt;a href=&quot;https://doc.rust-lang.org/std/result/&quot;&gt;https://doc.rust-lang.org/std/result/&lt;/a&gt;. This &lt;code&gt;io::Result&lt;/code&gt; example seems
to be similar enough to what I&#39;m doing, so let me see if I can fix
that up:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
use std::io::prelude::*;
use std::fs::File;
use std::io;

fn log_something(filename: &amp;amp;&#39;static str, string: &amp;amp;&#39;static [u8; 12]) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let mut f = try!(File::create(filename));
    try!(f.write_all(string));
}

fn main() {
    match log_something(&quot;log.txt&quot;, b&quot;ITS ALIVE!!!&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;
&lt;p&gt;
=&amp;gt;
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
$ cargo run
   Compiling simple-log v0.1.0 (file:///Users/joel/Projects/simple-log)
src/main.rs:5:1: 8:2 error: not all control paths return a value [E0269]
src/main.rs:5 fn log_something(filename: &amp;amp;&#39;static str, string: &amp;amp;&#39;static [u8; 12]) -&amp;gt; io::Result&amp;lt;()&amp;gt;
 {
src/main.rs:6     let mut f = try!(File::create(filename));
src/main.rs:7     try!(f.write_all(string));
src/main.rs:8 }
error: aborting due to previous error
Could not compile `simple-log`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;


&lt;p&gt;
After some time thinking, I see the problem:
an &lt;code&gt;Ok(())&lt;/code&gt; statement must be added as the final statement in
&lt;code&gt;log_something&lt;/code&gt;. I realized this because I saw that this is how things
happen in the &lt;code&gt;Result&lt;/code&gt; documentation.
&lt;/p&gt;

&lt;p&gt;
I&#39;ve been used to the idea that not having something after the final
semicolon means &lt;code&gt;return ()&lt;/code&gt;; however, the message &quot;not all control
paths return a value&quot; doesn&#39;t make sense &amp;#x2013; to me, this is a type
mismatch. Unless, of course, &lt;code&gt;()&lt;/code&gt; is not a value, which it might not
be, but I still think that&#39;s confusing.
&lt;/p&gt;

&lt;p&gt;
Our final result (for this post):
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
use std::io::prelude::*;
use std::fs::File;
use std::io;

fn log_something(filename: &amp;amp;&#39;static str, string: &amp;amp;&#39;static [u8; 12]) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
    let mut f = try!(File::create(filename));
    try!(f.write_all(string));
    Ok(())
}

fn main() {
    match log_something(&quot;log.txt&quot;, b&quot;ITS ALIVE!!!&quot;) {
        Ok(..) =&amp;gt; println!(&quot;File created!&quot;),
        Err(..) =&amp;gt; println!(&quot;Error: could not create file.&quot;)
    }
}
&lt;/pre&gt;
&lt;p&gt;
=&amp;gt;
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
$ rm log.txt
$ cargo run
     Running `target/debug/simple-log`
File created!
$ cat log.txt
ITS ALIVE!!!
&lt;/pre&gt;

&lt;p&gt;
Ok, it works. Great. I&#39;m going to end here because this has been pretty
challenging. I&#39;m sure improvements could be made on this code, but
this is a good stopping point and a good time to research dates and
times in Rust, which will be the &lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-2b/&quot;&gt;the next post&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-8&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-8&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;8&lt;/span&gt; Updates&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-8&quot;&gt;
&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;NMSpaz pointed out
&lt;a href=&quot;https://www.reddit.com/r/rust/comments/38ahgr/a_simple_web_app_in_rust_part_2a/crvvhkf&quot;&gt;on Reddit&lt;/a&gt;
that one of my examples had an error in it.
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
&amp;#x2014;
&lt;/p&gt;

&lt;p&gt;
Series: A Simple Web App in Rust
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-1/&quot;&gt;Part 1&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-2a/&quot;&gt;Part 2a&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-2b/&quot;&gt;Part 2b&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-3/&quot;&gt;Part 3&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-pt-4-cli-option-parsing/&quot;&gt;Part 4&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://joelmccracken.github.io/entries/a-simple-web-app-in-rust-conclusion/&quot;&gt;Conclusion&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;footnotes&quot;&gt;
&lt;h2 class=&quot;footnotes&quot;&gt;Footnotes: &lt;/h2&gt;
&lt;div id=&quot;text-footnotes&quot;&gt;

&lt;div class=&quot;footdef&quot;&gt;&lt;sup&gt;&lt;a id=&quot;fn.1&quot; name=&quot;fn.1&quot; class=&quot;footnum&quot; href=&quot;#fnr.1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;p class=&quot;footpara&quot;&gt;
lol.
&lt;/p&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;</description>
        <pubDate>Sat, 30 May 2015 00:00:00 -0400</pubDate>
        <link>http://joelmccracken.github.io//entries/a-simple-web-app-in-rust-pt-2a/</link>
        <guid isPermaLink="true">http://joelmccracken.github.io//entries/a-simple-web-app-in-rust-pt-2a/</guid>
      </item>
    
  </channel>
</rss>
