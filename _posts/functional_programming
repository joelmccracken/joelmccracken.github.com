http://www.defmacro.org/ramblings/fp.html
http://www.defmacro.org/ramblings/haskell-productivity.html

As I have been learning Scheme and working through SICP, I have really started to appreciate functional programming. [Slava Akhmechet][] has written a thorough, entertaining article detailing the history and benefits of functional programming. As of yet, the greatest personal benefit of functional programming is the simplification of what I need to store in my head at any given moment while programming. I know that for a given function, I need only think about the input and output, and how I get there. Also, the tendency to write huge functions which do multiple things is greatly diminished because of how functional programming makes you think.

   [Slava Akhmechet]: http://www.defmacro.org/ramblings/fp.html

<p>I have been on the lookout for a practical problem to introduce functional programming to programmers who do not have experience with it, and making a convincing argument as to why functional programming leads to a clear solution. I leave it to the reader to create a comparable algorithm in a traditional, iterative programming language like Java.

Disclaimer: I am no expert at functional programming, but I have seen its usefulness in simplifying problems and creating a stream of code that is highly logical.

<h3>Basics of Functional Programming</h3>
Readers who are new to Scheme would be well-served by reading any number of introductory tutorials in Scheme. However, since the point of this post is to convince you, the reader, that Scheme and functional programming is an effective, the remainder of this post is to give the necessary skills to understand the example problem and solution. 

In order to show that these methods are general to functional programming, my friend Steev has offered to translate appropriate bits of Scheme into Haskell, another functional programming language. Haskell focuses on mathematical purity and code brevity, and has a great deal of other interesting ideas.

Since Scheme is a Lisp variant, it uses the S-expression (sexp) style for code. Scheme programs look like:
<blockquote>
<code>(<em>function argument1 argument2 argument3 ...</em>)</code>
</blockquote>
Sexps can be nested: 



<blockquote><code>(+ (- 5 4) 3 2 1)</code> <em>returns 7</em></blockquote>



Thus, we have the method of representing all our logic using this simple, easy-to-parse syntax. 

Lists are the fundamental data structures in Scheme. A list has the form <code>(item1 item2 item4 item5)</code> <a href="#1">[1]</a>. Lists are constructed through the function <code>list</code> (alternately, the shorthand syntax of <code>'(item1 item2 item3 item4 item5)</code> can be used). Two fundamental functions are used to access lists: <code>car</code> and <code>cdr</code>. The function <code>car</code> returns the first item in the list, and <code>cdr</code> returns the second item in the list. These functions are extremely simplistic, and are best explained by example:

<blockquote>
<code>
; Scheme comments begin with a semicolon, and continue until the end of the line

; we create a list (1 2 3)
(list 1 2 3)

; access the first item in a list
(car (list 1 2 3)) ; returns 1

; access the rest of the list
(cdr (list 1 2 3)) ; returns (2 3)

; put them together to access the second item in the list
(car (cdr (list 1 2 3))) ; returns 2

; a list with only the third item
(cdr (cdr (list 1 2 3))) ; returns (3)

; and, we want to get the third item
(car (cdr (cdr (list 1 2 3)))) ; returns 3
</code>
</blockquote>

High-order functions are functions that either accept functions as parameters, or return other functions. One such function is <code>map</code>.


<blockquote>
<code>map <em>function</em> <em>list</em></code></blockquote>



The function <code>map</code> accepts a function and a list, and returns a list where each member of the previous list has had the function applied to it. Consider the code: 
<blockquote>
<pre><code>
(define (square x)
     (* x x))

(define (square-all x)
     (map square x))

(square-all (list 1 2 3)) ; this returns (1 4 9)
</code></pre>
</blockquote>

<p>The previous code introduced function creation. It follows the form:
<blockquote>
<code><pre>
(define (<em>function-name arg1 arg2 ...</em>) 
	(<em>function-body</em>))    
</pre></code>
</blockquote>

Anonymous functions are functions that have no name associated with them. They are typically used only once as a single, specific, simple block of logic. They follow the form: 

<blockquote>
<code><pre>
(lambda (<em>arg1 arg2 .</em>)
	(<em>function-body</em>))
</pre></code>
</blockquote>

With this in mind, the function <code>square-all</code> could have sensibly been written as

<blockquote>
<code><pre>
(define (square-all x)
	(map 	    (lambda (y) (* y y))
		    x))
</pre></code>
</blockquote>

We now know how to create functions (via the <code>define</code> and <code>lambda</code> functions), create lists (via the <code>list</code> function and <code>'(...)</code> form), access the members of a list (via <code>car</code> and <code>cdr</code>. That should be enough to begin to begin to explain the 8 Queens problem and solution in part 2. The scheme functions and issues to be discussed in part 2 are more problem-specific, and less general-purpose than these functions. 

<a name="1">[1]</a> Notice the similarity between the code structure and this datatype? This is the basis for the Lisp idea of code-as-data.

