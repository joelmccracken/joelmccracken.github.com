---
layout: post
title: "Writing a 'Human Resource Machine' Emulator in Elm"
date: 2016-06-05T22:01:24-04:00
---

I'm working on an Elm emulator for the the game
/[[http://tomorrowcorporation.com/humanresourcemachine][Human Resource Machine]]/.
The goal of the game is to solve problems with a sort of "assembly-like" language,
which you put together by dragging commands around as blocks.
Its a basically a "visual" assembly language.
The exercises have been fun and challenging enough to keep me interested.

Each level is presented as a conveyor belt inbox, a conveyor belt outbox, and some place to work with.
The player is asked to transform the input in some way, using the commands that are available for this level.

I thought it would be a fun exercise to write an emulator for the the game in Elm.
I want to fix a number of usability issues I see in the game.
Also, I've been wanting to learn to write more games.
While this isn't a game, it is closely tied to a game,
and scratches many of the same creative itches.

I'm still learning Elm, so this code probably has many flaws. Still, I
believe it is useful to see things through my eyes, as they are, now.
If you notice something that could be better, please, let me know
in the comments.
* Goals and Ideas
What would make a good online emulator, something that people might find worth using?
- The HRM editor is very basic. While good, I find it frustrating because of the inability
  to write comments, among other things.
  Later on in the game, you gain the ability to create little comment-y slips of paper, but
  this requires you
  to actually "draw" the words with your mouse/trackpad. It is really, really bad.
  I'd much rather work with "normal" comments, and there is no practical reason
- Instead of working with text, in HRM you drag around boxes with words in them. This is more akin
  to programming with the MIT scratch project than traditional programming. This
  is OK, and I think it is a good idea for beginners, but I personally want to write text.
* MVP
I first wanted to write a "proof-of-concept", from which I can add more features, over time.

The smallest design that I could come up with for this proof-of-concept is:
- Only emulate the first level, which has the most basic set of instructions.
- Each second, apply the next instruction to the machine state.
- Show the machine state after each instruction is calculated.

The first level consists of a simple task: For each item on an inbox conveyor belt, place it on the outbox conveyor belt.
We are given two possible instructions: 'inbox', and 'outbox'. The 'inbox' command instructs the character to pick
something up off the inbox
and hold it in their hands. The 'outbox' command says to place whatever is being held on the outbox.
* The Program
Lets go through the solution, piece by piece, starting with the most straightforward pieces first.

The easiest way to represent instructions is as a Union type:
#+BEGIN_SRC elm
type Instruction = Inbox
                 | Outbox
#+END_SRC

Hard-coding the solution program as an array of instructions makes this MVP easier:

#+BEGIN_SRC elm
program : Array Instruction
program =
  Array.fromList
         [ Inbox
         , Outbox
         , Inbox
         , Outbox
         , Inbox
         , Outbox
         ]
#+END_SRC

It seems like every Elm program has a "Model" type, and this is no exception:

#+BEGIN_SRC elm

type alias Model =
    { program : Array Instruction
    , state  : MachineState
    }
#+END_SRC

So, model is a combination between a program and an emulated "machine".

There is some forward thinking going on in this design. The model /could/ be
slightly simpler for this MVP, but part of the goal of this iteration is to
explore what the solution may look like in the future.

- ~program~ is listed as part of the model, although it needn't be in this case,
  since it is hard-coded and won't change. However, we want this to be different
  very soon, so it makes sense to just put this on the model, for now.

- ~state~ is a separate type because in the future I want to maintain a list of all states,
  for debuggability. It becomes just a little easier to refactor to a list if it is
  separate, and allows for a little bit of exploration of what a ~MachineState~ type
  should contain.

#+BEGIN_SRC elm
type alias MachineState =
    { complete : Bool
    , held     : Value
    , input    : List Value
    , output   : List Value
    , pc       : Int
    }
#+END_SRC
- ~complete~ signifies execution completion. I strongly suspect that this will go somewhere else, as
  it feels strange to have it in here. But, this is OK for now.
- ~held~ represents the current value that is being held. In HRM, what you
  hold is akin to a CPU register; your character do calculations with and moves values to and
  from their hands -- which, really, is just like real life.
- ~input~ represents the input conveyor. Values are taken from it and manipulated.
- ~input~ represents the output conveyor, onto which values are placed.
- ~pc~ represents the "program counter". This is the next instruction to be executed.

You may notice that the above references a ~Value~. This is the "values" that may be worked with
in the game:
#+BEGIN_SRC elm
type Value = VInt Int
           | VNothing
#+END_SRC
For now, we are only working with integers. It is also possible for something that stores a value
to be empty, which is represented as ~VNothing~.

You might think that the VNothing is similar to ~Maybe~ (http://package.elm-lang.org/packages/elm-lang/core/4.0.1/Maybe).
I think it is, too. I remember that in later levels the game works with letters, so I think there
needs to be /some/ special type here.
